{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Uvicore - Fullstack Async Python","text":"<p>     Uvicore       The Full Stack Asynchronous Python Framework with the performance of FastAPI and the elegance of Laravel! </p> <ul> <li> Code github.com/uvicore/framework</li> <li> Docs Getting Started</li> <li> Package pypi.org/project/uvicore</li> </ul>"},{"location":"#full-stack-elegance","title":"Full Stack Elegance","text":"<ul> <li> <p> Dual Routers</p> <p>Blazing fast dual routing engine based on FastAPI and Starlette!</p> </li> <li> <p> Async Everywhere</p> <p>Await all the things, even your CLI's thanks to AsyncClick!</p> </li> <li> <p> Inversion of Control</p> <p>Powerful IoC container! Full control to your app! Override everything!</p> </li> <li> <p> Adapters For Everything</p> <p>Swap drivers for caching, auth, events, database and more and the touch of a config!</p> </li> <li> <p> Extremely Modular</p> <p>Apps are modules, modules are apps.  No more \"parent shell\" required to run your packages!</p> </li> <li> <p> Expressive ORM!</p> <p>Custom ORM build on SQLAlecheny Core and Pydantic!</p> </li> </ul>  \" Uvicore is the missing fullstack asynchronous framework for elegant and rapid python development \""},{"location":"#why-uvicore","title":"Why Uvicore?","text":"<p>Fullstack, Modular and Asynchronous. A Full Solution for Web, API and CLI Development!</p> <p>Micro frameworks are great!  They become the building blocks for larger structures and fullstack frameworks.  Starlette and FastAPI for example are fantastic building blocks.  But most projects require structure, standards and many libraries and layers that work together.</p>"},{"location":"#full-stack-vs-micro-frameworks","title":"Full Stack vs Micro Frameworks","text":"<p>Uvicore is built on many libraries and modules including FastAPI, Starlette, Pydantic and SQLAlchemy.</p> <p>Uvicore Streamlines the Developer Experience by providing:</p> <ul> <li>Structure and folder standardizations for large projects.</li> <li>Scaffolding to generate entire projects and individual classes and methods.</li> <li>Modularization with no \"shell\".  Every app is a module and every module is an app.</li> <li>Config First drive modules with deep nesting and override power.</li> <li>IoC container for Inversion of Control to swap any implementation.</li> <li>Custom ORM on top of SQLAlchemy Core and Pydantic.</li> <li>Automatic Model Router drives deep nested API endpoints instantly from your relational models.</li> <li>Authentication middleware for easy token based API authentication with any standards IDP.</li> </ul>"},{"location":"#inspiration","title":"Inspiration","text":"<ul> <li>Heavily inspired by the amazing PHP Laravel Framework.</li> <li>Inspired by Django, Django Rest Framework, Starlette and FastAPI.</li> <li>Uvicore utilizes Starlette as the \"web\" router.</li> <li>Uvicore utilizes FastAPI as the \"api\" router and OpenAPI document generation.</li> <li>Uvicore utilizes smurfix/asyncclick for full async CLIs that can await your existing async methods.</li> <li>Uvicore utilizes SQLAlchemy \"core\" and encode/databases, but adds its own custom ORM for elegant queries and models.</li> <li>Uvicore glues all the pieces together with the Laravel inspired Service Provider methodology.</li> </ul>"},{"location":"auto-api/","title":"Auto API","text":"<p>Uvicore has an automatic CRUD Model Router for API usage which can be enabled in your <code>http/routes/api.py</code> like so</p> <pre><code># http/routes/api.py\ndef register(self, route: ApiRouter):\n    # ...\n\n    # Include dynamic model CRUD API endpoints (the \"auto API\")!\n    # These routes are automatically protected by model.crud style permissions.\n    route.include(ModelRouter)\n\n    # ...\n</code></pre> <p>For every uvicore model, multiple API endpoints are automatically created to perform CRUD operations on the list of models via <code>/users</code> or a single model via <code>/users/{id}</code>.  You can see these new routes when viewing the OpenAPI doc endpoint at <code>http://localhost:5000/api/docs</code></p>"},{"location":"auto-api/#permissions","title":"Permissions","text":"<p>When a uvicore model is created, a set of <code>model.crud</code> style permissions are automatically generated and stored in the <code>permissions</code> database table.  For example</p> entity name users users.create users users.read users users.update users users.delete <p>When visiting <code>GET</code> <code>http://localhost:5000/api/users</code> the user must have the <code>users.read</code> scope.  Scopes are the same as these permission strings.</p> <p>Note</p> <p>Permissions and Scopes are the same thing.  You limit all endpoints using the <code>scopes=[]</code> List which are linked to the <code>user/groups/roles</code> in the database as <code>permissions</code>.</p> <p>Each auto API endpoint is limited by the proper scope.</p> <ul> <li><code>HTTP GET</code> requires the <code>users.read</code> scope.</li> <li><code>HTTP POST</code> requires the <code>users.create</code> scope.</li> <li><code>HTTP PUT</code> requires the <code>users.update</code> scope.</li> <li><code>HTTP PATCH</code> requires the <code>users.update</code> scope.</li> <li><code>HTTP DELETE</code> requires the <code>users.delete</code> scope.</li> </ul>"},{"location":"auto-api/#making-some-endpoints-public","title":"Making Some Endpoints Public","text":"<p>If you want some auto API endpoints public and some private, even down to public GET vs POST you should keep the automatic CRUD scopes enabled and instead link UserID 1 (the anonymous user) to a role and link up the proper permissions for that role.  Public users are actually assigned a real uvicore user called anonymous, so user groups, roles and permissions apply to that public anonymous user just like any other user.</p>"},{"location":"auto-api/#make-it-all-public","title":"Make it all Public","text":"<p>If you wanted ALL auto API endpoints to be wide open to the public, with no limiting scopes (permissions) at all, use the <code>options</code> parameter and set the <code>scopes</code> key to a blank List.</p> <pre><code># http/routes/api.py\ndef register(self, route: ApiRouter):\n    # ...\n\n    # Include dynamic model CRUD API endpoints (the \"auto API\")!\n    # These routes are automatically protected by model.crud style permissions.\n    route.include(ModelRouter, options={\n        'scopes': []\n    })\n\n    # ...\n</code></pre> <p>Tip</p> <p>Although the auto API endpoints now have no scopes themselves, they still obey any higher order <code>scopes</code> you may have defined in your top level router or controller files.</p>"},{"location":"auto-api/#custom-scopes-without-crud-scopes","title":"Custom scopes without CRUD scopes","text":"<p>If you wanted to remove the automatic CRUD scopes (permissions) from all auto API endpoints and instead define your own List of scopes for all endpoints.</p> <pre><code># http/routes/api.py\ndef register(self, route: ApiRouter):\n    # ...\n\n    # Include dynamic model CRUD API endpoints (the \"auto API\")!\n    # These routes are automatically protected by model.crud style permissions.\n    route.include(ModelRouter, options={\n        'scopes': ['authenticated', 'autoapi_user']\n    })\n\n    # ...\n</code></pre> <p>Notice these scopes apply to every single endpoint. User must be authenticated and have the <code>autoapi_user</code> permission.  They can hit ALL auto API endpoints with all HTTP verbs.</p> <p>This is only handy if you want to give out ALL functionality to a set of users.  This is not a granular per HTTP verb approach.  To define a custom set of permissions for each HTTP verb use a scopes dictionary instead.  Like so</p> <pre><code># http/routes/api.py\ndef register(self, route: ApiRouter):\n    # ...\n\n    # Include dynamic model CRUD API endpoints (the \"auto API\")!\n    # These routes are automatically protected by model.crud style permissions.\n    route.include(ModelRouter, options={\n        'scopes': {\n            'create': ['autoapi.create'],\n            'read': ['autoapi.read'],\n            'update': ['autoapi.update'],\n            'delete': ['autoapi.delete'],\n        }\n    })\n\n    # ...\n</code></pre> <p>Although this is granular from an HTTP verb standpoint, it still applies to every single endpoint.</p> <p>Tip</p> <p>Any higher order <code>scopes</code> defined in top level routes or controllers are also obeyed</p>"},{"location":"auto-api/#extend-existing-crud-scopes","title":"Extend existing CRUD scopes","text":"<p>If you wanted to extend/append your own scopes to the existing automatic <code>model.crud</code> styles scopes, wrap it in a <code>@route.group</code> decorator</p> <p><pre><code># http/routes/api.py\ndef register(self, route: ApiRouter):\n    # ...\n\n    # Include dynamic model CRUD API endpoints (the \"auto API\")!\n    # These routes are automatically protected by model.crud style permissions.\n    @route.group(scopes=['authenticated', 'autoapi_user']):\n    def autoapi():\n        route.include(ModelRouter)\n\n    # ...\n</code></pre> Now a user must have the actual CRUD scope (ex: <code>users.read</code>) and also the <code>authenticated</code> and <code>autoapi_user</code> scope.</p> <p>Tip</p> <p>Any higher order <code>scopes</code> defined in top level routes or controllers are also obeyed</p>"},{"location":"auto-api/#notes","title":"Notes","text":"<p>Notes from within the model_router.py, moved here</p> <p>REST Notes <pre><code>There are certain verbs which must NOT carry a body/payload.  Instead they act on a single resource defined in the URL.  These verbs are GET/HEAD/DELETE/OPTIONS.  Which means you can only DELETE a /{id} resource, never bulk with some sort of DELETE body payload.  Body in DELETE is technically allowed, but is generally ignored by clients, proxies and should not be used.  Get obviously has no body whatsoever, only URL and possibly queryParameters.\n\nencode/httpx for example does not allow body data on GET/HEAD/DELETE/OPTIONS as expected.\n\nFurther, some verbs that do except body payload should still only ever act on a single resource defined in the url /{id}.  Like PUT.  PUT should never do bulk inserts.  PUT acts on a single resource to UPDATE that resource using the URL /{id}.  PUT can have a body/payload, which is the FULL resource to UPDATE.\n\nAt first I created my DELETE to accept\n\nhttps://www.restapitutorial.com/lessons/httpmethods.html\nPUT should be idempotent always, if it increments a counter, its NOT idempotent and POST should be used\n\nGET\nHas NO body/payload\n/user       To get entire collection\n/user/{id}  to get a single item\nqueryParams are OK on either / or /{id}\n\nPOST - creating, but also a catch-all verb\nHas body/payload\n/user           To create a new user (not idempotent), body can be one or many items\n/user/delete    Custom, can have a body payload with complex query of WHAT to delete\n\n\n\n\n\nhttps://stackoverflow.com/questions/299628/is-an-entity-body-allowed-for-an-http-delete-request\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2020JanMar/0123.html\nhttps://stackoverflow.com/questions/21863326/delete-multiple-records-using-rest\n\n\n\n\nhttps://www.mscharhag.com/p/rest-api-design\nhttps://www.mscharhag.com/api-design/http-post-put-patch\n\nGET\nHEAD\nOPTIONS\nTRACE\n\n\nPOST is for new records\n    POST /spaces\n    Not idempotent as it will continue to create new resources\n    If new post, return 200\n    If endpoint has no response but created, return 204 (no content but success)\n\nPUT is for updating existing records whos ID is in the url\n    PUT /spaces/123\n    Not for partial updates, expects the FULL object\n    Idempotent\n\nPATCH\n    PATCH /spaces/123\n    Like PUT, but can be partial object, or could be full, either way\n    Updates only records defined in the partial object\n    {\n        'creator': 4\n    }\n\n    BULK updates?\n    PATCH /spaces?where={\"something\": \"other\"}\n    Takes a partial JSON blob, with the data you want to update in BULK\n    {\n        'something': 'new',\n        'title': 'all get the same title'\n    }\n\nDELETE\n    DELETE /spaces/123\n    Deletes one space by ID\n    maybe a new permission string spaces.update_bulk?\n\n    BULK?\n    DELETE /spaces?where={\"creator_id\": 1}\n    maybe a body with confirm code?\n    {\n        env API_BULK_DELETE_CODE: 1234123412341234123412341234\n        confirm: yes sir code 123423412341234\n    }\n    or maybe a new permission string, spaces.delete_bulk?\n</code></pre></p> <p>URL query notes <pre><code>Include\n-------\ninclude=sections.topics\n\nWhere AND\n----------\nwhere={\"id\": 1}\nwhere={\"id\": 1, \"name\": \"test\"}\n\nwhere={\"id\": [\"&gt;\", 1]}\n\nwhere={\"id\": [\"in\", [\"one\", \"two\"]]}\nwhere={\"id\": [\"&gt;\", 5], \"name\": \"asdf\", \"email\": [\"like\", \"asdf\"]}\n\n\nWhere OR\n--------\nor_where=(id,1)+(id,3)\n\nGroup By\n--------\n\nOrder By\n--------\norder_by=[{\"id\": \"ASC\"}, {\"name\": \"DESC\"}]\n\nPaging\n------\npage=1\nsize=10\ntranslates to ORM limit and offset\n\nCache\n-----\ncache=60  in seconds\n</code></pre></p>"},{"location":"bootstrap/","title":"Bootstrap","text":""},{"location":"cache/","title":"Cache","text":""},{"location":"cache/#summary","title":"Summary","text":"<p>Uvicore comes with a built-in caching system capable of connecting to any number of backend storage services.  Uvicore currently ships with <code>Redis</code> and <code>In App Memory</code> caching backends.  Additional backend drivers can easily be created by the community.</p> <p>The caching system is generally used to cache expensive database queries or other data lookups.  But of course, you are free to use it for any arbitrary key/value storage.  Just remember, cache is not a database, it expires unless you define otherwise.  Even still, it should be considered volatile.</p>"},{"location":"cache/#configuration","title":"Configuration","text":"<p>Most of uvicore's configuration is set to sensible defaults with quick and easy <code>.env</code> file overrides.</p> <p>By default, caching is set to use the <code>array</code> store.  This means you can start using caching right away without any further configuration.</p> <p>If you want to switch to a <code>Redis</code> backend caching system, simply edit your <code>.env</code> file and configure these simple values <pre><code># Cache redis connection\nREDIS_CACHE_HOST=127.0.0.1\nREDIS_CACHE_PORT=6379\nREDIS_CACHE_DB=2\n\n# Cache configuration\nCACHE_STORE=redis\nCACHE_EXPIRE=600\n</code></pre></p> <p>Tip</p> <p><code>.env</code> file tweaks are all you need to get started.  You are good to go.</p> <p>If you want to dig deeper into the configuration, keep reading...</p> <p>All cache configuration is done at the running application level.  This means your <code>config/app.py</code> config.  In that file you will notice this entry <pre><code>    # --------------------------------------------------------------------------\n    # Cache Configuration\n    # If no cache config defined, the default of 'array' caching will be used\n    # --------------------------------------------------------------------------\n    'cache': {\n        'default': env('CACHE_STORE', 'array'),  # redis, array\n        'stores': {\n            'redis': {\n                'driver': 'uvicore.cache.backends.redis.Redis',\n                'connection': 'cache',\n                'prefix': env('CACHE_PREFIX', 'acme.appstub::cache/'),\n                'seconds': env.int('CACHE_EXPIRE', 600),  # 0=forever\n            },\n        },\n    },\n</code></pre> This entire top-level <code>cache</code> config key is optional.  If not defined, caching is defaulted to using the <code>array</code> store.  Caching can never be \"disabled\", because other packages you depend on may be using a ton of cache calls.  The default of <code>array</code> ensures those calls function properly even if you don't have Redis or some other backend available.</p> <p>In this example, the <code>stores</code> Dict contains one cache store by a named key <code>redis</code>.  The <code>default</code> string defines which store is used when you make a call to <code>uvicore.cache</code> without explicitly defining which store to use.  Simply adjusting your <code>.env</code> with <code>CACHE_STORE=redis</code> ensures all calls to cache will now be using the <code>redis</code> store.</p> <p>The <code>driver</code> section defines the backend python adapter that handles redis caching, in this case, the built-in <code>uvicore.cache.backends.redis.Redis</code> python module.  Any community member can create a cache compatible backend by examining that module and adhering to the <code>CacheInterface</code>.</p> <p>The <code>prefix</code> section defines the prefix added to each key that is saved to cache.  Good for Redis if you have dozens of apps using cache.  This prefix is also how <code>cache.flush()</code> can delete all cache entries it \"owns\" without flushing the entire Redis database.</p> <p>The <code>seconds</code> are the default expiration given to each cache key.  Cache is generally meant to expire.  If you don't ever want key/values to expire, set <code>seconds: 0</code>.  This config defines the default behavior of <code>cache.put()</code> and other save methods.  You can also override each individual call using the optional seconds parameter <code>cache.put('mykey', 'myvalue', seconds=50)</code></p> <p>The <code>connection</code> key is pointing to a redis database connection key which is defined in your packages <code>config/package.py</code> configuration.  All packages created from the Uvicore Installer already contain a <code>cache</code> redis connection key.  All you have to do is ensure your <code>.env</code> has the proper values to override it. <pre><code>    # --------------------------------------------------------------------------\n    # Redis Connections\n    # --------------------------------------------------------------------------\n    'redis': {\n        'default': env('REDIS_DEFAULT', 'wiki'),\n        'connections': {\n            'wiki': {\n                'host': env('REDIS_WIKI_HOST', '127.0.0.1'),\n                'port': env.int('REDIS_WIKI_PORT', 6379),\n                'database': env.int('REDIS_WIKI_DB', 0),\n                'password': env('REDIS_WIKI_PASSWORD', None),\n            },\n            'cache': {\n                'host': env('REDIS_CACHE_HOST', '127.0.0.1'),\n                'port': env.int('REDIS_CACHE_PORT', 6379),\n                'database': env.int('REDIS_CACHE_DB', 2),\n                'password': env('REDIS_CACHE_PASSWORD', None),\n            },\n        },\n    },\n</code></pre></p>"},{"location":"cache/#stores","title":"Stores","text":"<p>Uvicore ships with 2 backend cache stores, <code>Redis</code> and <code>Array</code>.  The community (that means YOU) may easily create other stores like memcache.</p> <p>The <code>array</code> store simply stores cached data in the running apps memory.  Array store does have full TTL expiry!  It should act just like redis cache except that it is in your running apps memory.  When the app dies, cache is gone forever.  This means cache entries with no expiry (seconds=0) will disappear when the app stops. Array is best used for testing or when you import another uvicore package that uses caching, but you don't have redis and don't really care about the cache.</p>"},{"location":"cache/#expiration","title":"Expiration","text":"<p>All values inserted to the cache store always use the config expire TTL seconds. This means all keys will automatically delete themselves.  You can override each insert operation using the optional <code>seconds=</code> parameter.  Using <code>seconds=0</code> means the key will NEVER expire.  If you want every key to persist forever, update your config seconds to 0.</p>"},{"location":"cache/#usage","title":"Usage","text":"<p>You can obtain a cache instance in multiple ways.  The easiest and recommended method is to simply use <code>uvicore.cache</code> since <code>import uvicore</code> is most likely already at the top of every file you will use. <pre><code>import uvicore\nuvicore.cache.get('key1')\n\n\n# Or\n\nimport uvicore.cache\ncache.get('key1')\n</code></pre></p> <p>You can optionally get the cache instance from the IoC either by <code>uvicore.ioc.make</code> or by simply importing the cache manager.  In either case, you must manually <code>connect()</code> to start using the cache. <pre><code># These options require you to run .connect().  If .connect() has no parameters, the default\n# cache store is used from your config.  You may also specify the store with .connect('redis')\nfrom uvicore.cache.manager import Manager as Cache\ncache = Cache.connect()\n\n# Or using .make()\ncache = uvicore.ioc.make('cache').connect()\n</code></pre></p> <p>Use an alternate store other than the default defined in your config <pre><code>await cache.store('redis').get('key1')\n</code></pre></p> <p>Get one or more values from cache <pre><code># Get a single value by key\nawait cache.get('key1')\n\n# Get a dictionary of multiple key value pairs if requesting multiple keys\nawait cache.get(['key1', 'key2'])\n</code></pre></p> <p>Get one or more values from cache with a default value if not exists.  If key does not exist return a DEFAULT value, but do NOT set that default back to the cache store. <pre><code>await cache.get('missing1', default='default if not found')\n\n# Works with multiple key value pairs.  Returned dictionary will either have the data\n# for each key, or use the default value\nawait cache.get(['missing1', 'key1'], default='not found')\n</code></pre></p> <p>The <code>.remember()</code> method will get one or more values if exist, if not, it will set the default to the cache store and return it.  Different that <code>.get()</code> with a <code>default=</code> because <code>.remember()</code> will set the default in the cache store.  This is the recommended method to automatically cache expensive database queries or lookups into cache.  Works with callbacks! <pre><code># Single key value\nawait cache.remember('key1', 'default key3')\n\n# Multiple key value returns.  If any one does not exist, the default is SET in the cache store\nawait cache.remember(['key1', 'key2'], 'default value')\n\n# Using custom TTL seconds\nawait cache.remember('key1', 'default value', seconds=60)\n\n# Default can be a callback.  This is ideal for retrieving a value from cache if exists.  If not\n# exist, run a complex query and set the queries results into the cache.\nasync def wiki_posts():\n    return await Post.query().get()\nawait cache.remember('all_posts', wiki_posts)\n</code></pre></p> <p>Check if a single cache key exists <pre><code>await cache.has('key1')\n</code></pre></p> <p>Put a single key value in cache <pre><code>await cache.put('key1', 'value1')\n\n# If no seconds is passed, uses default TTL seconds from config\nawait cache.put('key1', 'value1', seconds=60)\n</code></pre></p> <p>Put multiple key value pairs into cache <pre><code>await cache.put({\n    'key3': 'value 3',\n    'key4': 'value 4',\n})\n# with optional seconds= parameter\n</code></pre></p> <p>Pull one or more values from cache and delete after retrieval. Like get, but once retrieved, cache entry is DELETED. <pre><code># Single pull\nawait cache.pull('key1')\n\n# Multiple\nawait cache.pull(['key1', 'key2'])\n</code></pre></p> <p>Add a single value only if not exists.  Like put, but will not overwrite an existing value. <pre><code># Return true if success (meaning key did not exist and we added it), otherwise\n# false for already exists\nawait cache.add('key1', 'value1')\n</code></pre></p> <p>Touch a key.  This alters the last access time of a key but does not retrieve the value. If <code>seconds=</code> are passed it will RESET the TTL to the given seconds. <pre><code># Update the last access time, but do NOT modify the TTL\nawait cache.touch('key1')\n\n# Update the last access time and reset the TTL to seconds=\nawait cache.touch('key1', seconds=60)\n\n# Returns true if key exists and we touched or modified the TTL.  False if key does not exist.\n</code></pre></p> <p>Increment a key.  If key does not exist, it will create it.  Increment returns the current value after the increment <pre><code># Uses default TTL seconds\nnew_int = await cache.increment('key1')\n\n# Custom TTL seconds expire\nawait cache.increment('key1', seconds=60)\n\n# Custom increment integer\nawait cache.increment('key1', 10)\n</code></pre></p> <p>Forget (delete) one or more keys <pre><code># A single key\nawait cache.forget('key1')\n\n# Multiple keys\nawait cache.forget(['key1', ['key2'])\n</code></pre></p> <p>Delete all cache keys.  This is \"redis safe\" as it only deletes keys in the redis database that begin with the cache prefix defined in your config.  It does NOT delete all keys in your database! <pre><code>await cache.flush()\n</code></pre></p>"},{"location":"events/","title":"Events","text":""},{"location":"events/#fixme","title":"FIXME","text":"<p>I added a new dispatch_async.  Basically events should either be sync or async.  For example, all bootstrapping events are sync since bootstrap is sync.  But all events coming from any async source like a route or a database query must be async as well.  So the ORM for example will dispatch all events as dispatch_async therefore those events are async and all handlers should also be async.</p>"},{"location":"events/#introduction","title":"Introduction","text":"<p>Uvicore provides an observer (pub/sub) implementation allowing you to listen (subscribe) to events that occur in the framework and in your own packages.</p> <p>Events are a great way to decouple various aspects of your project.  A single event can have many listeners that need not depend on each other.  For example, each time a wiki post is created you may wish to send an email or slack notification to all watchers of the post.</p> <p>All events must be pre-registered with uvicore.  This allows the framework to know all possible events for all packages.  Running <code>./uvicore events list</code> will show you this events database.</p> <p>Events are dispatched throughout the framework and other packages.  When an event is dispatched all defined listeners will be called in order they were added.  Listeners define the event(s) to watch and the event handlers (callbacks) to fire when then event is dispatched.  Handlers can be methods, classes or even bulk listening/handling subscriptions.</p>"},{"location":"events/#defining-your-own-events","title":"Defining Your Own Events","text":"<p>The first step in creating your own events is to pick an event name, then register that event with the framework.  The best place to register your own events is in your package Service Provider <code>register()</code> method.</p> <p>Register Events</p> <pre><code># services/wiki.py\nfrom uvicore.support.provider import ServiceProvider\n\nclass Wiki(ServiceProvider):\n\n    def register(self):\n\n        # Register events used in this package\n        self.events({\n            'mreschke.wiki.events.post.Created': {\n                'description': 'Wiki post has been created',\n                'type': 'class',\n                # ...\n                # There is no set definition of what should be here.  This is\n                # your own metadata for an event.  Could define log output\n                # text, log icons or sections, priority, severity or anything\n                # you want.  This metadata is passed along to each handler.\n            },\n            'mreschke.wiki.events.post.Deleted': {\n                'description': 'Wiki post has been deleted',\n                'type': 'class',\n            },\n        })\n    # ...\n</code></pre> <p>The second step is OPTIONAL.  You must decide if you want to create a matching event class that acts as a payload container and parameter contract.  Or simply treat the event as a string based event with Dictionary payload parameters.</p> <p>The benifits of an event class are that you can force the payload requirements using the class <code>__init__()</code> constructor.  An event class performs NO work.  It is simply a data container for the payload itself.  Event classes are typically stored in the <code>events</code> directory of your package.  If using a simple string to define an event, it is best practice to name the string as if it were going to be an actual event class someday.  For example <code>mreschke.wiki.events.post.Created</code>. If at some point you want to create the actual class, all existing listeners that use that string will not need to be changed as the system looks for a class of the same name to instantiate.</p> <p>Event Payload Class</p> <pre><code># events/post.py\nfrom uvicore.events import Event\nfrom mreschke.wiki.models import Post\n\nclass Created(Event):\n\n    def __init__(self, post: Post):\n        self.post = post\n</code></pre> <p>That's it.  Seems simple.  An event class contains no logic.  It is simply a container with a constructor that forces a specific payload.  This helps constrain the dispatch code and also provides Code IDE intellisense when newing up the event to dispatch.  This class is completely optional.  The event can still be dispatched without it.</p>"},{"location":"events/#dispatching-events","title":"Dispatching Events","text":"<p>You can fire off (dispatch) a registered event in a few different ways.  Where you fire off the event is up to your own code.  With the Wiki events example above the proper place may be in your controller, model or job that Creates and Deletes wiki posts.  Wherever the location, fireing off an event is simple.</p> <p>As a String</p> <p>The framework will use this string to check if a matching event class exists. If the class exists it will import it and new it up using the dictionary as the <code>__init__()</code> constructor parameters.  If the class does not exist, this event will still fire as usual using the dictionary as an unconstrained payload. <pre><code>from uvicore import events\nevents.dispatch('mreschke.wiki.events.post.Created', {'post': post})\n</code></pre></p> <p>As a Class Instance</p> <p>You can new up the event class yourself.  The benefits of this over the string approach is IDE auto-completion.  Your IDE will show you the exact parameters required to new up the class.  The payload is now constrained to a contract.</p> <p>When newing up the event class yourself you have two options of how to dispatch it. <pre><code>from uvicore import events\nfrom mreschke.wiki.events import Created\n\n# Using the events.dispatch() method to pass in the class instance\nevents.dispatch(Created(post))\n\n# Or by using the event classes build-in .dispatch() method\nCreated(post).dispatch()\n</code></pre></p> <p>However you dispatch your events, all listeners are immediately fired in order they were defined.</p>"},{"location":"events/#listening-to-events","title":"Listening to Events","text":"<p>Registering and then dispatching events do nothing if there is no one listening. Listeners define callbacks that are executed when an event is dispatched.</p> <p>The best place to register your event listeners is in your package Service Provider <code>register()</code> method which has access to <code>self.listen</code> and <code>self.subscribe</code> event helper methods.</p> <p>Listen to a single event</p> <pre><code># From service provider register() method\n\n# Use a local method (function) as the callback\nself.listen('mreschke.wiki.post.Created', self.NotifyUsers)\n\n# Use a listener class as the callback\nself.listen('mreschke.wiki.post.Created', 'mreschke.wiki.listeners.NotifyUsers')\n</code></pre> <p>Info</p> <p>Notice the <code>mreschke.wiki.listeners.NotifyUsers</code> class is defined as a string in dot notation.  The event system will automatically instantiate and call the class <code>handle()</code> method during dispatch.</p> <p>Listen to multiple events</p> <pre><code># From service provider register() method\n\n# Use a local method (function) as the callback\nself.listen([\n    'mreschke.wiki.post.Created',\n    'mreschke.wiki.post.Deleted',\n], self.NotifyUsers)\n\n# Use a listener class as the callback\nself.listen([\n    'mreschke.wiki.post.Created',\n    'mreschke.wiki.post.Deleted',\n], 'mreschke.wiki.listeners.NotifyUsers')\n</code></pre> <p>Listen to wildcard events</p> <pre><code># From service provider register() method\n\n# Use a local method (function) as the callback\nself.listen('uvicore.foundation.events.*', self.NotifyUsers)\n\n# Use a listener class as the callback\nself.listen('uvicore.foundation.events.*', 'mreschke.wiki.listeners.NotifyUsers')\n\n# The * wildcard also works in the middle of an event name\nself.listen('mreschke.wiki.models.*.Deleted', self.LogDeletions)\n</code></pre> <p>Registering a subscriber</p> <p>A subscription is an all-in-one class which listens to one or more events and also contains the handlers for each event.  Notice we are not defining the event to listen to here.  We simply define the subscription class.  See Handling Events for what these classes look like. <pre><code># From service provider register() method\nself.subscribe('mreschke.wiki.listeners.HttpEventSubscription')\n</code></pre></p>"},{"location":"events/#listeners-outside-a-service-provider","title":"Listeners outside a Service Provider","text":"<p>You can also listen and subscribe to events outside of a service provider by using the <code>uvicore.events</code> instance.</p> <pre><code>from uvicore import events\nevents.listen('mreschke.wiki.post.Created', self.my_handler)\nevents.subscribe('mreschke.wiki.listeners.HttpEventSubscription')\n</code></pre>"},{"location":"events/#handling-events","title":"Handling Events","text":"<p>Handlers are callbacks that are dispatched when an event fires.  Handlers are defined using <code>listen()</code> or <code>subscribe()</code> methods as noted in Listening To Events.</p> <p>Handlers can be basic python methods (functions) or dedicated handler classes.</p> <p>All handlers receive an <code>event: Dict</code> and <code>payload: Any</code>.  The <code>event</code> dictionary is the metadata for an event that was defined by the developer during the event registration.  If the event listener is a class, the payload will be an instance of that class with properties of all constructor parameters. If the event listener is just a string, the payload is a <code>namedtuple</code> of parameters.</p> <p>Method Handler</p> <pre><code>def my_handler(event: Dict, payload: Any) -&gt; None:\n    # Do work when this event is dispatched.\n</code></pre> <p>Class Handler</p> <pre><code>from typing import Dict, Any\nfrom uvicore.events.handler import Handler\n\nclass NotifyUser(Handler):\n\n    def handle(self, event: Dict, payload: Any):\n        # Instance variable self.app is also available to you\n        # Do work when this event is dispatched.\n</code></pre> <p>Subscription Handlers</p> <p>Subscriptions are a great way to listen and handle multiple events from a single file.</p> <pre><code>from typing import Dict, Any\nfrom uvicore.contracts import Dispatcher\n\nclass AppEventSubscription:\n\n    def app_registered(self, event: Dict, payload: Any):\n        #  Do something when then the framework is done registering all providers\n\n    def app_booted(self, event: Dict, payload: Any):\n        #  Do something when then the framework is done booting all providers\n\n    def post_created(self, event: Dict, payload: Any):\n        #  Do something when a wiki post is created\n\n    def subscribe(self, events: Dispatcher):\n        # A subscription is an all in one class that can both listen AND handle\n        # one or more events in a single place.\n        events.listen('uvicore.foundation.events.app.Registered', self.app_registered)\n        events.listen('uvicore.foundation.events.app.Booted', self.app_booted)\n        events.listen('mreschke.wiki.post.Created', self.post_created)\n</code></pre>"},{"location":"http/","title":"HTTP Web &amp; API","text":"<p>FIXME</p> <ul> <li> Intro about web vs api routers</li> <li> API Routes</li> <li> API Model Router</li> <li> API Controllers</li> <li> API Authentication</li> </ul>"},{"location":"ioc/","title":"Service Container","text":"<p>IoC</p>"},{"location":"jobs/","title":"Jobs","text":""},{"location":"jobs/#defining-a-job","title":"Defining a Job","text":"<p>Create a <code>jobs</code> folder (or whatever name you like) and create a job file, example <code>jobs/train.py</code></p> <pre><code>import uvicore\nfrom uvicore.jobs.job import Job\n\n@uvicore.job()\nclass Train(Job):\n    \"\"\"Train the Model\"\"\"\n\n    def __init__(self, topic: Topic, revision: Revision, file: str):\n        self.topic = topic\n        self.revision = revision\n        self.file = file\n\n    async def handle(self):\n        dump('train job handler here')\n</code></pre>"},{"location":"jobs/#dispatch-the-job","title":"Dispatch the Job","text":"<p>You can dispatch sync or async jobs like so</p> <p>From jobs.dispatch <pre><code>from uvicore import jobs\nfrom acme.wiki.jobs import Train\n\n# Sync\njobs.dispatch(Train(topic=1, revision=5, file='/tmp/x'))\n\n# Or await if your handle() is async\nawait jobs.codispatch(Train(topic=1, revision=5, file='/tmp/x'))\n</code></pre></p> <p>From the class Instance Itself <pre><code>from acme.wiki.jobs import Train\n\n# Sync\nTrain(topic=1, revision=5, file='/tmp/x').dispatch()\n\n# Or await if your handle() is async\nawait Train(topic=1, revision=5, file='/tmp/x').codispatch()\n</code></pre></p>"},{"location":"mail/","title":"Mail","text":"<p>Sending email</p> <p>As Mail() parameters <pre><code>from uvicore.mail import Mail\n\nx = Mail(\n    #mailer='smtp',\n    #mailer_options={'port': 124},\n    to=['to@example.com'],\n    cc=['cc@example.com'],\n    bcc=['bcc@example.com'],\n    from_name='Matthew',\n    from_address='from@example.com',\n    subject='Hello1',\n    html='Hello1 &lt;b&gt;Body&lt;/b&gt; Here',\n    attachments=[\n        '/tmp/test.txt',\n        '/tmp/test2.txt',\n    ]\n)\nawait x.send()\n</code></pre></p> <p>As Mail() method chaining <pre><code>from uvicore.mail import Mail\nx = (Mail()\n    #.mailer('mailgun')\n    #.mailer_options({'port': 124})\n    .to(['to@example.com'])\n    .cc(['cc@example.com'])\n    .bcc(['bcc@example.com'])\n    .from_name('Matthew')\n    .from_address('from@example.com')\n    .subject('Hello1')\n    .text('Hello1 &lt;b&gt;Body&lt;/b&gt; Here')\n    .attachments([\n        '/tmp/test.txt',\n        '/tmp/test2.txt',\n    ])\n)\nawait x.send()\n</code></pre></p> <p>FIXME.  Add docs on route background tasks.  How to send email using starlette background on a route.</p>"},{"location":"mkdocs-help/","title":"Mkdocs and Material","text":""},{"location":"mkdocs-help/#common-links","title":"Common Links","text":"<p>Service Provider Pydantic Uvicore CLI SuperDict</p> <p>IoC</p> <p>Uvicore Installer</p> <p>encode/databases</p> <p>SQLAlchemy Core</p> <p>View Composers</p>"},{"location":"mkdocs-help/#common-names","title":"Common names","text":"<p>yourname.yourapp</p>"},{"location":"mkdocs-help/#common-paragraphs","title":"Common paragraphs","text":"<p>In order to use the database layer with Uvicore you must first ensure you have installed the <code>database</code> extras from the framework.  This is by default already included in the <code>uvicore-installer</code>. <pre><code># Poetry pyproject.toml\nuvicore = {version = \"0.1.*\", extras = [\"database\", \"redis\", \"web\"]}\n\n# Pipenv Pipfile\nuvicore = {version = \"==0.1.*\", extras = [\"database\", \"redis\", \"web\"]}\n\n# requirements.txt\nuvicore[database,redis,web] == 0.1.*\n</code></pre></p> <p>After the database extras have been installed you must update your <code>config.package.py</code> <code>dependencies</code> OrderedDict in <code>config/package.py</code> <pre><code>    'dependencies': OrderedDict({\n        'uvicore.foundation': {\n            'provider': 'uvicore.foundation.services.Foundation',\n        },\n        # ...\n        'uvicore.database': {\n            'provider': 'uvicore.database.services.Database',\n        },\n        # ...\n    }),\n</code></pre></p>"},{"location":"mkdocs-help/#admonitions","title":"Admonitions","text":"<p>https://squidfunk.github.io/mkdocs-material/reference/admonitions/</p> <p>Note</p> <p>This is the <code>!!! note</code> admonition</p> <p>Abstract</p> <p>This is the <code>!!! abstract</code> admonition</p> <p>Info</p> <p>This is the <code>!!! info</code> admonition</p> <p>Custom Title Here</p> <p>This is the <code>!!! info \"Custom Title Here\"</code> admonition</p> <p>Tip</p> <p>This is the <code>!!! tip</code> admonition with a code block</p> <pre><code>def hi():\n    \"\"\"Code in a admonition provided by superfences\"\"\"\n    pass\n</code></pre> <p>No title use \"\"</p> <p>Check</p> <p>asdf</p> <p>With title</p> <p>Warning here</p> <p>Danger</p> <p>asdfasdfasdf asdf</p> Collapsible Admonition <p>Collapsible note Plus means default to open</p> <p>Seealso</p> <p>asdfasdfasdf asdf</p>"},{"location":"mkdocs-help/#content-tabs","title":"Content Tabs","text":"<p>Example</p> Mac <pre><code>do mac stuff\n</code></pre> Linux <pre><code>do linux stuff\n</code></pre>"},{"location":"mkdocs-help/#footnotes","title":"Footnotes","text":"<p>Lorem ipsum<sup>1</sup> dolor sit amet, consectetur adipiscing elit.<sup>2</sup></p>"},{"location":"mkdocs-help/#icons-and-emojis","title":"Icons and Emojis","text":"<p>Smile Emoji </p> <p>See https://emojiguide.com/ or https://emojipedia.org for all emoji.</p> <p>I use the twitter emoji</p> <p>You can also just paste \ud83e\uddd2 emoji right in markdown.  Or use things like </p> <p>This theme comes with these 3 FULL SETS of icons!</p> <ul> <li> \u2013 <code>.icons/material/account-circle.svg</code></li> <li>:fontawesome-regular-laugh-wink: \u2013 <code>.icons/fontawesome/regular/laugh-wink.svg</code></li> <li>:octicons-octoface-16: \u2013 <code>.icons/octicons/octoface-16.svg</code></li> </ul>"},{"location":"mkdocs-help/#tasklist","title":"Tasklist","text":"<ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul> <ol> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.\u00a0\u21a9</p> </li> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. multi line\u00a0\u21a9</p> </li> </ol>"},{"location":"release-notes/","title":"Release Notes","text":"<p>rn</p>"},{"location":"request-lifecycle/","title":"Request Lifecycle","text":"<p>asdf</p>"},{"location":"service-providers/","title":"Service Providers","text":"<p>Your packages service provider is located at <code>services/yourapp.py</code></p>"},{"location":"superdict/","title":"SuperDict","text":""},{"location":"todo/","title":"ToDo","text":""},{"location":"todo/#orm","title":"ORM","text":"<p>May want to revisit if ORM can handle SQLAlchemy binary expressions.  Some are OK, but take .where() for example.</p> <p>Look at query.py _build_orm_queries when I am processing query2 wheres.  I am using split.  Cannot split on a binary expression.  Of course I could match with relation.entity.tablename == self._column(where[0], query2.tablename but there are other issues, namely that a relations name will not be the same as the columns tablename.  And for the wheres I am stripping no just the matching relations wheres but also the sub-relations under it using the relation columns string name.  So self._column() name is space_section for example, but in spaces the relation name is called just 'sections'.  I would have to do a lot of work to convert a column into a relations string.</p> <p>But not sure binary expressions are important for an ORM anyhow.  For DB builder, YES, but nor for ORM.  In fact I don't even have any ORM tests written yet that use binary expressions.  Could just remove?  Revisit!</p> <p>Need executors for .delete() and .update(), example User.query().where(...).delete() User.query().where(...).update('name', 'bulk rename')</p>"},{"location":"cli/","title":"CLI","text":"<p>Uvicore has an asynchronous Click command line that allows you to call your existing Uvicore async methods thanks to AsyncClick!</p> <p>In uvicore, the CLI, Web and API are simply entrypoints into your apps async functionality.  Therefore the CLI must await your async methods just as your HTTP controllers do.</p> <p>The <code>./uvicore</code> CLI provides access to your own apps async commands as well as Uvicore's own built in command like 'http serve' and 'db reseed'!</p>"},{"location":"cli/built-in-commands/","title":"Built-In Commands","text":"<p>Because your package depends on several Uvicore packages, there are many commands available in your './uvicore' command interface.</p>"},{"location":"cli/built-in-commands/#uvicore-app","title":"./uvicore app","text":""},{"location":"cli/built-in-commands/#uvicore-app-info","title":"./uvicore app info","text":"<p>This command shows you detailed info about the running app/package</p>"},{"location":"cli/built-in-commands/#uvicore-config","title":"./uvicore config","text":""},{"location":"cli/built-in-commands/#uvicore-event","title":"./uvicore event","text":""},{"location":"cli/built-in-commands/#uvicore-gen","title":"./uvicore gen","text":""},{"location":"cli/built-in-commands/#uvicore-ioc","title":"./uvicore ioc","text":""},{"location":"cli/built-in-commands/#uvicore-package","title":"./uvicore package","text":""},{"location":"cli/commands/","title":"Console Commands","text":"<p>Uvicore uses asyncclick to provide elegant click command line interfaces that allow you to <code>await</code> all your existing async methods!</p>"},{"location":"cli/commands/#uvicore-command-interface","title":"Uvicore Command Interface","text":"<p>All uvicore packages come with a <code>./uvicore</code> CLI.</p> <p>This CLI allow you to interact with your packages CLI commands, Uvicore's Built-In Commands, and any other commands provided by packages you depend on.</p> <pre><code>./uvicore\n</code></pre> <p>Output <pre><code>Usage: uvicore [OPTIONS] COMMAND [ARGS]...\n\n  Uvicore 0.2.0\n  The Fullstack Async Web, API and CLI Python Framework\n\n  Copyright (c) 2023 Matthew Reschke License http://mreschke.com/license/mit\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  app      Uvicore Application Information\n  config   Configuration Information\n  event    Uvicore Event Information\n  gen      Generate New Schematics (commands, models, views...)\n  ioc      Uvicore Ioc (Inversion of Control) Information\n  package  Uvicore Package Information\n  myapp    MyApp Commands\n</code></pre></p> <p>Not only are your own apps commands available from this interface, but other Uvicore and 3rd party module commands are also available.</p>"},{"location":"cli/commands/#build-in-commands","title":"Build in Commands","text":"<p>Uvicore comes with several build-in commands to view your configs, routes, IoC bindings and package information.</p> <p>Explore the built-in Uvicore CLI Commands!</p>"},{"location":"cli/python-entrypoints/","title":"Python Entrypoints","text":"<p>Using <code>./uvicore</code> directly in app is a great way to bundle many packages commands into a single executable, but often we need actual <code>setuptools entrypoints</code>.</p> <p>Sometimes those <code>entrypoints</code> might run a single click command, and sometimes they might run a <code>click group</code> of commands.</p>"},{"location":"cli/python-entrypoints/#entrypoint-for-a-single-command","title":"Entrypoint for a Single Command","text":"<p>To create a <code>setuptools entrypoint</code> for a single command edit your packages <code>pyproject.toml</code> file like so: <pre><code>[tool.poetry.scripts]\nwelcome = \"myapp.commands.welcome:cli\"\n</code></pre></p> <p>Ensure your poetry virtual environment is activated.</p> <p>After this change you must run <code>poetry install</code> to register the new entrypoint.</p> <p>Now you can simply run <code>welcome</code> from bash instead of using <code>./uvicore myapp welcome</code>.</p>"},{"location":"cli/python-entrypoints/#entrypoint-for-a-click-command-group","title":"Entrypoint for a Click Command Group","text":"<p>To create a <code>setuptools entrypoint</code> for a <code>click group</code> edit your packages <code>pyproject.toml</code> file like so: <pre><code>[tool.poetry.scripts]\nmyapp = 'myapp.commands.entrypoint:cli'\n</code></pre></p> <p>You must create this custom <code>commands/entrypoint.py</code> file to handle this <code>click group</code>.</p> <p>This boostraps uvicore and dynamically adds all of this main apps commands into a click group specifically made for this <code>setuptools entrypoints</code></p> <pre><code>import os\nimport sys\nimport uvicore\nfrom uvicore.console import group\nfrom myapp.package import bootstrap\nfrom uvicore.support.module import load\n\n# Bootstrap the Uvicore application from the console entrypoint\napp = bootstrap.Application(is_console=True)()\n\n# Define a new asyncclick group\n@group()\ndef cli():\n    pass\n\n# Dynamically add in all commands from this package matching this command_group\ncommand_group='myapp'\npackage = uvicore.app.package(main=True);\nif 'console' in package:\n    if (package.registers.commands and uvicore.app.is_console):\n        for key, group in package.console['groups'].items():\n            if key == command_group:\n                for command_name, command_class in group.commands.items():\n                    cli.add_command(load(command_class).object, command_name)\n\n# Instantiate the asyncclick group\ntry:\n    cli(_anyio_backend='asyncio')\nexcept KeyboardInterrupt:\n        try:\n            sys.exit(0)\n        except SystemExit:\n            os._exit(0)\n</code></pre> <p>Ensure your poetry virtual environment is activated.</p> <p>After this change you must run <code>poetry install</code> to register the new entrypoint.</p> <p>Now you can simply run <code>myapp welcome</code> or <code>myapp --help</code> from bash instead of using <code>./uvicore myapp welcome</code>.</p>"},{"location":"cli/writing-commands/","title":"Writing Commands","text":"<p>In addition to the commands provided by Uvicore and other dependent packages, you may also build your own custom commands.  Commands are stored in your packages <code>commands/</code> directory.</p>"},{"location":"cli/writing-commands/#generating-commands","title":"Generating Commands","text":"<p>To create new commands, you can use the <code>./uvicore gen command</code> schematic generator or build them by hand.</p> <pre><code>./uvicore gen command --help\n</code></pre> <p>Output <pre><code>Usage: uvicore gen command [OPTIONS] NAME\n\n  Generate a new CLI command schematic...\n\n  USAGE:\n      Commands should be lower_underscore and SINGULAR (plural is OK)\n      Remember to manually add the command to your service provider!\n\n      ./uvicore gen command welcome\n      ./uvicore gen command process\n      ./uvicore gen command scan_files\n\nOptions:\n  --help  Show this message and exit.\n</code></pre></p>"},{"location":"cli/writing-commands/#registering-commands","title":"Registering Commands","text":"<p>Once you generate your new command, you must register your command with Uvicore.</p> <p>You must define your commands in your packages <code>package/provider.py</code> Provider inside the <code>boot()</code> method.</p> <p>You may register commands as a dictionary</p> <pre><code>def boot(self) -&gt; None:\n    # You can define CLI groups and commands as a complete dictionary\n    self.register_cli_commands({\n        'myapp': {\n            'help': 'MyApp Commands',\n            'commands': {\n                'welcome': 'myapp.commands.welcome.cli',\n                'other': 'myapp.commands.other.cli',\n            },\n        },\n    })\n</code></pre> <p>Or you you may register commands as <code>kwargs</code></p> <pre><code>def boot(self) -&gt; None:\n    # Or you can define commands as kwargs (multiple calls to self.commands() are appended)\n    self.register_cli_commands(\n        group='myapp',\n        help='MyApp Commands',\n        commands={\n            'welcome': 'myapp.commands.welcome.cli',\n            'other': 'myapp.commands.other.cli',\n        },\n    )\n</code></pre>"},{"location":"cli/writing-commands/#calling-commands","title":"Calling Commands","text":"<p>Use the <code>./uvicore</code> CLI interface to interact with your commands.</p> <pre><code>./uvicore myapp\n</code></pre> <p>Output</p> <pre><code>Usage: uvicore myapp [OPTIONS] COMMAND [ARGS]...\n\n  MyApp Commands\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  welcome  Welcome to Uvicore\n  other    My Other Command\n</code></pre> <p>Execute your <code>welcome</code> command</p> <pre><code>./uvicore myapp welcome\n</code></pre>"},{"location":"cli/writing-commands/#command-structure","title":"Command Structure","text":"<p>Here is an example of a basic command with no arguments or parameters.  The <code>\"\"\"Welcome to Uvicore\"\"\"</code> document block is the help text that shows in your <code>./uvicore</code> CLI output.</p> <pre><code>import uvicore\nfrom uvicore.support.dumper import dump, dd\nfrom uvicore.exceptions import SmartException\nfrom uvicore.console import command, argument, option\n\n\n@command()\nasync def cli():\n    \"\"\"Welcome to Uvicore\"\"\"\n    # ex: ./uvicore myapp welcome\n    try:\n\n        print(\"\"\"Welcome to a Uvicore Example CLI Command!\n\nThis command lives in your commands/welcome.py file and is registered with the CLI\nin your package/provider.py boot() method.  Create as many CLI commands as needed\nand be sure to checkout the commands included with the uvicore packages.\n\n~mReschke\"\"\")\n\n    except SmartException as e:\n        # Python exit() with any value means \"error\" in bash exit code speak!\n        exit(e.detail)\n</code></pre> <p>Here is an example of a more advanced command with arguments and options.</p> <pre><code>import uvicore\nfrom uvicore.support.dumper import dump, dd\nfrom uvicore.exceptions import SmartException\nfrom uvicore.console import command, argument, option\n\n@command(help=\"My Other Command\")\n@argument('id_or_name')\n@option('--tenant', help='Tenant')\n@option('--coin', default='BTC', help='Coin with Default')\n@option('--json', is_flag=True, help='Output results as JSON')\nasync def get(id_or_name: str, tenant: str, coin: str, json: bool):\n    # ex: ./uvicore myapp other --tenant bob --json\n    try:\n        # Do stuff\n        dd(id_or_name, tenant, coin, json)\n    except SmartException as e:\n        # Python exit() with any value means \"error\" in bash exit code speak!\n        exit(e.detail)\n</code></pre> <p>Required Options</p> <pre><code>@command()\n@option('--topic', required=True, help='Topic ID')\n@option('--revision', required=True, help='Revision I')\nasync def cli(topic: int, revision: int):\n    \"\"\"Train a Topic Revision\"\"\"\n    try:\n        dump('Do it')\n\n    except SmartException as e:\n        # Python exit() with any value means \"error\" in bash exit code speak!\n        exit(e.detail)\n</code></pre>"},{"location":"database/config/","title":"Database Configuration","text":"<p>Uvicore utilizes encode/databases as an async adapter for SQLAlchemy Core (core is the query builder only, NO SQLAlchemy ORM).  This was in place before SQLAlchemy 1.4 came out, which is now async.  At some point Uvicore will be updated to remove the <code>encode/databases</code> dependency.  Keep in mind that Uvicore does NOT utilize SQLAlchemy for an ORM as Uvicore has a custom Pydantic based ORM that is more fluent and elegant.</p> <p>Because Uvicore database utilizes SQLAlchemy Core, Uvicore supports any database engine that SQLAlchemy supports including MySQL, PostgreSQL, MSSQL etc...</p>"},{"location":"database/config/#dependency","title":"Dependency","text":"<p>In order to use the database layer with Uvicore you must first ensure you have installed the <code>database</code> extras from the framework.  This is by default already included in the <code>uvicore-installer</code>. <pre><code># Poetry pyproject.toml\nuvicore = {version = \"0.1.*\", extras = [\"database\", \"redis\", \"web\"]}\n\n# Pipenv Pipfile\nuvicore = {version = \"==0.1.*\", extras = [\"database\", \"redis\", \"web\"]}\n\n# requirements.txt\nuvicore[database,redis,web] == 0.1.*\n</code></pre></p> <p>After the database extras have been installed you must update your <code>config.package.py</code> <code>dependencies</code> OrderedDict in <code>config/package.py</code> <pre><code>    'dependencies': OrderedDict({\n        'uvicore.foundation': {\n            'provider': 'uvicore.foundation.services.Foundation',\n        },\n        # ...\n        'uvicore.database': {\n            'provider': 'uvicore.database.services.Database',\n        },\n        # ...\n    }),\n</code></pre></p> <p>Notice the ORM dependency does not need to be defined.  Uvicore can use a raw query builder level database access layer without an ORM.</p>"},{"location":"database/config/#connection-strings","title":"Connection Strings","text":"<p>Uvicore uses your <code>config/package.py</code> configuration file to store connection strings. Add the proper connection, be sure to use the <code>.env</code> file along with the <code>env()</code> helper to keep your secrets out of git.</p> <pre><code>config = {\n    # ...\n    'database': {\n        'default': env('DATABASE_DEFAULT', 'yourapp'),\n        'connections': {\n            # SQLite Example\n            # 'yourapp': {\n            #     'driver': 'sqlite',\n            #     'database': ':memory',\n            #     'prefix': None,\n            # },\n\n            # MySQL Example\n            'yourapp': {\n                'driver': env('DB_YOURAPP_DRIVER', 'mysql'),\n                'dialect': env('DB_YOURAPP_DIALECT', 'pymysql'),\n                'host': env('DB_YOURAPP_HOST', '127.0.0.1'),\n                'port': env.int('DB_YOURAPP_PORT', 3306),\n                'database': env('DB_YOURAPP_DB', 'yourapp'),\n                'username': env('DB_YOURAPP_USER', 'yourdbuser'),\n                'password': env('DB_YOURAPP_PASSWORD', 'password'),\n                'prefix': env('DB_YOURAPP_PREFIX', None),\n            },\n        },\n    },\n    # ...\n}\n</code></pre> <p>Note</p> <p>The reason this is stored in <code>config/package.py</code> instead of <code>config/app.py</code> is because <code>config/package.py</code> is meant to be overridden by any developer consuming your app as a package inside their own app.  The package consumer gets to change where your package stores data.  Devs can also override using their <code>.env</code> file so be sure to use <code>env('XYZ')</code> in your configs.</p> <p>From the Uvicore CLI, you can see all deeply merged connection strings for your app and any Uvicore package dependencies that use the DB by running <pre><code>./uvicore db connections\n</code></pre></p>"},{"location":"database/orm-basics/","title":"ORM Basics","text":""},{"location":"database/orm-basics/#introduction","title":"Introduction","text":"<p>asdf</p>"},{"location":"database/orm-basics/#hooks","title":"Hooks","text":"<p>In your model, you can override these defs</p> <pre><code># New records only, actual INSERTS\n_before_insert(self)\n_after_insert(self)\n\n# Both insert or update, any save to the database\n_before_save(self)\n_after_save(self)\n\n# Delete\n_before_delete(self)\n_after_delete(self)\n</code></pre>"},{"location":"database/orm-basics/#events","title":"Events","text":"<p>The ORM hooks also fire named string based events to use anywhere else in the system.  String is based on the models FQN (fully qualified name).  For example if the model is <code>uvicore.auth.models.user.User</code> the event names would be</p> <pre><code>uvicore.orm-{uvicore.auth.models.user.User}-BeforeInsert\nuvicore.orm-{uvicore.auth.models.user.User}-AfterInsert\n\nuvicore.orm-{uvicore.auth.models.user.User}-BeforeSave\nuvicore.orm-{uvicore.auth.models.user.User}-AfterSave\n\nuvicore.orm-{uvicore.auth.models.user.User}-BeforeDelete\nuvicore.orm-{uvicore.auth.models.user.User}-AfterDelete\n</code></pre>"},{"location":"database/orm-model/","title":"ORM Model","text":""},{"location":"database/orm-model/#summary","title":"Summary","text":"<p>About ORM models</p>"},{"location":"database/orm-model/#opendocs-example-override","title":"OpenDocs Example Override","text":"<p>The OpenAPI docs will provide an automatic example for request and response results based on your model schema.  You can override this default example by leveraging the Pydantic inheritance of your ORM models.  Pydantic provides a <code>Config</code> class with a <code>schema_extra.example</code> section.</p> <pre><code>@uvicore.model()\nclass Post(Model['Post'], metaclass=ModelMetaclass):\n    \"\"\"Yourapp Posts\"\"\"\n\n    # Pydantic configuration override\n    class Config:\n        schema_extra = {\n            \"example\": {\n                \"id\": 1,\n                \"slug\": \"title-as-a-slug\",\n                #...\n            },\n        }\n    #...\n</code></pre>"},{"location":"database/orm-model/#tables","title":"Tables","text":"<p>Most ORM models will have a corresponding database table (but they don't have to).  To define the table use the <code>__tableclass__</code> class variable to point to a proper uvicore table class.  If you want to inline your table definition you can do that as well.  See Database Tables for more information.</p>"},{"location":"database/orm-model/#tableless","title":"Tableless","text":"<p>ORM models do not require a corresponding database table.</p> <p>Perhaps you are creating an API passthrough with a custom schema or</p>"},{"location":"database/orm-pydantic/","title":"Pydantic","text":""},{"location":"database/orm-querybuilder/","title":"ORM Query Builder","text":"<p>Examples use a Uvicore model called <code>User</code> and <code>Post</code>.</p> <p>I also show the API URL parameters used in the automatic model router.</p>"},{"location":"database/orm-querybuilder/#find-one","title":"Find One","text":"<p>Find one user by primary key of 1.  Returns a single User model instance, not a List. <pre><code>user = await User.query().find(1)\n# URL: /users/1\n</code></pre></p> <p>Find one user by email.  Returns a single User model instance, not a List.  If this happens to return multiple results from the Database, TOP 1 is returned, never a List. <pre><code>user = await User.query().find(email='mreschke@example.com')\n# URL: /users?where=[\"email\",\"mreschke@example.com\"]\n</code></pre></p> <p>Tip</p> <p><code>.find()</code> ignores any <code>.where()</code>, <code>.or_where()</code>, <code>.order_by()</code>, <code>.key_by()</code> as those do not apply to finding a single record.</p>"},{"location":"database/orm-querybuilder/#get-all","title":"Get All","text":"<p>Get all users.  Returns a List of User model instances. <pre><code>users = await User.query().get()\n# URL: /users\n</code></pre></p>"},{"location":"database/orm-querybuilder/#include-relations","title":"Include Relations","text":"<p>You can include child relations of any relational type by using <code>include()</code></p> <p><code>include()</code> can take infinite parameters or a List <pre><code># Infinite parameters\nposts = await Post.query().include('creator', 'comments').get()\n# URL:  /posts?include=creator,comments\n# URL2: /posts?include=creator&amp;include=comments\n\n# As a List\nposts = await Post.query().include(['creator', 'comments']).get()\n# URL:  /posts?include=creator,comments\n# URL2: /posts?include=creator&amp;include=comments\n</code></pre></p> <p>You can include any number of deeply nested relations using dot notation.  Assume the posts <code>creator</code> links to the <code>User</code> model.  Further the <code>User</code> model has a <code>info</code> one-to-one. <pre><code>posts = await Post.query().include('creator.info', 'comments.creator', 'tags').get()\n# URL:  /posts?include=creator.info,comments.creator,tags\n# URL2: /posts?include=creator.info&amp;include=comments.creator&amp;include=tags\n</code></pre></p> <p>Most other query builder methods on relations use dot notation as well. <pre><code>posts = await (Post.query()\n    .include('creator.info', 'comments.creator')\n    .where('deleted', False)\n    .where('creator.info.title', 'Master Gardner')\n    .filter('comments.deleted', False)\n    .sort('comments.created_at', 'DESC'),\n    .order_by('created_at')\n    .get()\n)\n</code></pre></p> <p>Info</p> <p>All relations in a dot notation will be included, so <code>creator.info</code> includes both creator <code>User</code> and the <code>Info</code> of that creator.  No need to specify twice as <code>['creator', 'creator.info']</code></p>"},{"location":"database/orm-querybuilder/#where","title":"Where","text":"<p>Operators</p> <p>Valid operators are <code>in, !in, like, !like, =, != &gt;, &gt;=, &lt;, &lt;=</code>. and <code>'null'</code> (in quotes) is a valid \"value\" (not operator), see null example below.</p> <p>Get all users with eye_color blue.  Operator is assumed <code>=</code>. <pre><code>users = await User.query().where('eye_color', 'blue').get()\n# URL: /users?where=[\"eye_color\",\"blue\"]\n</code></pre></p> <p>Explicit operator 2nd param is either the operator or the where value if operator is undefined. <pre><code>users = await User.query().where('eye_color', '=', 'blue').get()\n# URL: /users?where=[\"eye_color\",\"=\",\"blue\"]\n</code></pre></p> <p>Where In, Not In <pre><code>users = await User.query().where('eye_color', 'in', ['green', 'blue']).get()  # In\n# URL: /users?where=[\"eye_color\",\"in\",[\"green\", \"blue\"]]\n\nusers = await User.query().where('eye_color', '!in', ['green', 'blue']).get()  # Not in\n# URL: /users?where=[\"eye_color\",\"!in\",[\"green\", \"blue\"]]\n</code></pre></p> <p>Where Like, Not Like <pre><code>users = await User.query().where('eye_color', 'like', '%br%').get()  # Like\n# URL: /users?where=[\"eye_color\",\"like\",\"%br%\"]\n\nusers = await User.query().where('eye_color', '!like', '%br%').get()  # Not like\n# URL: /users?where=[\"eye_color\",\"!like\",\"%br%\"]\n</code></pre></p> <p>Where Null, Not Null <pre><code>users = await User.query().where('eye_color', 'null').get()  # Like\n# URL: /users?where=[\"eye_color\",\"null\"]\n\nusers = await User.query().where('eye_color', '!=', 'null').get()  # Not like\n# URL: /users?where=[\"eye_color\",\"!=\",\"null\"]\n</code></pre></p>"},{"location":"database/orm-querybuilder/#where-multiples","title":"Where Multiples","text":"<p>There is a few ways to add multiple wheres.  You can either chain multiple <code>.where()</code> together, or use a single <code>.where()</code> with a <code>List of Tuples</code>.  The Tuple style accepts all the optional operators just like the normal <code>.where()</code>.</p> <p>Multiple chains <pre><code>users = await User.query().where('eye_color', 'green').where('gender', '!=', 'male').get()\n# URL: /users?where=[[\"eye_color\",\"green\"],[\"gender\",\"!=\",\"male\"]]\n</code></pre></p> <p>List of Tuples <pre><code>users = await (User.query().where([\n    ('eye_color', 'green'),\n    ('gender', '!=', 'male'),\n]).get()\n# URL: /users?where=[[\"eye_color\",\"green\"],[\"gender\",\"!=\",\"male\"]]\n</code></pre></p>"},{"location":"database/orm-querybuilder/#where-or","title":"Where OR","text":"<p>Where ORs are a bit limited at the moment.   The OR only works at the end of a where in the final SQL statement.  Meaning you cannot do complex (and (or) and (or)) order of operations</p> <pre><code>users = await User.query().or_where([\n    ('eye_color', 'green'),\n    ('eye_color', '=', 'blue')\n]).get()\n# URL: /users?or_where=[[\"eye_color\",\"green],[\"eye_color\",\"=\",\"blue\"]]\n# SQL: SELECT * FROM User WHERE eye_color='green' OR eye_color='blue'\n</code></pre> <p>The <code>or_where</code> can be combined with <code>where</code> and any other query builder method <pre><code>users = await (User.query()\n    .where('gender', 'male')\n    .where('hair_color', 'blonde')\n    .or_where([\n        ('eye_color', 'green'),\n        ('eye_color', 'blue')\n    ]\n).get())\n# URL: /users?where=[[\"gender\",\"male\"],[\"hair_color\", \"blonde\"]]&amp;or_where=[[\"eye_color\",\"green\"],[\"eye_color\",\"blue\"]]\n# SQL: SELECT * FROM User WHERE gender='male' AND hair_color='blonde' AND (eye_color='green' OR eye_color='blue')\n</code></pre></p>"},{"location":"database/orm-querybuilder/#filter-children","title":"Filter Children","text":"<p>Filter is like <code>.where()</code> but only filters child relations.  For example you would use a <code>where</code> to get all posts by <code>creator_id=1</code> and <code>include('comments')</code>, but use a <code>filter</code> to filter the child comments to all non deleted comments.  Thus a <code>filter</code> is only applicable if you also have some <code>include()</code> defined that shows MANY children.</p> <p>Available chainables are <code>filter()</code> and <code>or_filter()</code></p> <pre><code>posts = await (Post.query()\n    .include('comments')\n    .where('creator_id', 1)\n    .filter('comments.deleted', False)\n    .get()\n)\n# URL: /posts?include=comments&amp;where=[\"creator_id\",1]&amp;filter=[\"comments.deleted\",false]\n</code></pre> <p>Tip</p> <p>The same rules for <code>where()</code> apply to <code>filter()</code>.  Meaning operator as 2nd parameter is optional.  Multiple filters may be either chained or used as a List of Tuples.  Just like <code>or_where()</code>, <code>or_filter()</code> is also available and has the same syntax.</p>"},{"location":"database/orm-querybuilder/#order-by","title":"Order By","text":"<p>Order by is used to sort the main table by one or more columns, either ascending (the default) or aescending.</p> <p>Get all posts ordered by <code>created_at</code> ascending.  Second param is optional, defaults to <code>ASC</code>. <pre><code>posts = await Post.query().order_by('created_at')\n# URL: /posts?order_by=created_at\n</code></pre></p> <p>Get all posts ordered by <code>created_at</code> descending.  Notice the API URL turns into JSON at this point. <pre><code>posts = await Post.query().order_by('created_at', 'DESC')\n# URL: /posts?order_by=[\"created_at\",\"DESC\"]\n</code></pre></p> <p>Order multiple columns, both by ASC.  Uses a <code>List of Tuples</code> <pre><code>posts = await Post.query().order_by([('creator_id'), ('created_at')])\n# URL: /posts?order_by=[[\"creator_id\"],[\"created_at\"]]\n</code></pre></p> <p>Order multiple columns, choosing ASC or DESC. <pre><code>posts = await Post.query().order_by([('creator_id'), ('created_at','DESC')])\n# URL: /posts?order_by=[[\"creator_id\"],[\"created_at\",\"DESC\"]]\n</code></pre></p>"},{"location":"database/orm-querybuilder/#sort-children","title":"Sort Children","text":"<p>Filter is like <code>.order_by()</code> but only sorts relations.  For example you would use an <code>order_by</code> to order all posts by <code>created_at DESC</code> but use a <code>sort</code> to sort the child comments by<code>created_at ASC</code>.  Thus <code>sort</code> is only applicable if you also have some <code>include()</code> defined that shows MANY children. <pre><code>posts = await (Post.query()\n    .include('comments')\n    .order_by('created_at', 'DESC')\n    .sort('comments.created_at')\n    .get()\n)\n# URL: /posts?include=comments&amp;order_by=[\"created_at\",\"DESC\"]&amp;sort=comments.created_at\n</code></pre></p> <p>You can also sort on many columns.  If a <code>List of Strings</code>, then no order is defined and the default of ASC (ascending) is used. <pre><code>posts = await (Post.query()\n    .include('comments')\n    .order_by('created_at', 'DESC')\n    .sort(['comments.created_at', 'comments.title'])\n    .get()\n)\n# URL: /posts?include=comments&amp;order_by=[\"created_at\",\"DESC\"]&amp;sort=[\"comments.created_at\",\"comments.title\"]\n</code></pre></p> <p>You can also define the sorting order, ASC or DESC by using a <code>List of Tuples</code> <pre><code>posts = await (Post.query()\n    .include('comments')\n    .order_by('created_at', 'DESC')\n    .sort([('comments.created_at', 'ASC'), ('comments.title', 'DESC')])\n    .get()\n)\n# URL: /posts?include=comments&amp;order_by=[\"created_at\",\"DESC\"]&amp;sort=[[\"comments.created_at\",\"ASC\"],[\"comments.title\",\"DESC\"]]\n</code></pre></p>"},{"location":"database/queries/","title":"Database Queries","text":""},{"location":"database/queries/#querybuilder","title":"QueryBuilder","text":"<p>xyz</p>"},{"location":"database/queries/#other","title":"Other","text":"<p>Maybe raw queries against an actual table module?</p>"},{"location":"database/queries/#raw-queries-without-table-modules","title":"Raw Queries without Table Modules","text":"<p>You can query database tables without a pre-defined SQLAlchemy table class.</p> <pre><code>query = f\"\"\"\n    SELECT\n        *\n    FROM\n        sometable\n    WHERE\n        -- Parameterization works, or can just use somekey = 'somevalue', but is less secure\n        somekey = :v\n\"\"\"\nparams= {\n    'v': 'parameterized value here',\n}\nresults = await uvicore.db.fetchall(query, params, connection='myapp')\n</code></pre> <p>Can also use <code>fetchone()</code> and <code>execute()</code> for INSERTS, UPDATES and DELETES</p>"},{"location":"database/tables/","title":"Database Tables","text":"<p>Uvicore provides two methods to define your SQLAlchemy tables.</p>"},{"location":"database/tables/#as-separate-files","title":"As Separate Files","text":"<p>Tables may be stored in separate files located in <code>database/tables/*</code>.  You may use the Uvicore schematic generator to create this table automatically, or create it by hand.</p> <pre><code>./uvicore gen table --help\n./uvicore gen table posts\n</code></pre> <p>init file</p> <p>Be sure to add your new table to the <code>database/tables/__init__.py</code></p> <p>The schematic includes many commented examples of how to use the table, a sort of auto-documentation.</p> <p>A basic <code>posts</code> table looks like this <pre><code>import uvicore\nimport sqlalchemy as sa\nfrom uvicore.database import Table\nfrom uvicore.support.dumper import dump\n\n# Get related table names with proper prefixes\nusers = uvicore.db.tablename('auth.users')\n\n@uvicore.table()\nclass Posts(Table):\n\n    # Actual database table name\n    # Plural table names and singluar model names are encouraged\n    # Do not add a package prefix, leave that to the connection config\n    name = 'posts'\n\n    # Connection for this database from your config file\n    connection = 'yourapp'\n\n    # SQLAlchemy Table definition as a list (exclude name and metadata)\n    # This will be converted into an actual SQLAlchemy Table() instance\n    # See https://docs.sqlalchemy.org/en/13/core/schema.html\n    schema = [\n        sa.Column('id', sa.Integer, primary_key=True),\n        sa.Column('unique_slug', sa.String(length=100), unique=True),\n        sa.Column('title', sa.String(length=100)),\n        sa.Column('body', sa.Text()),\n        sa.Column('other', sa.String(length=100), nullable=True),\n        sa.Column('creator_id', sa.Integer, sa.ForeignKey(f\"{users}.id\"), nullable=False),\n        sa.Column('owner_id', sa.Integer, sa.ForeignKey(f\"{users}.id\"), nullable=False),\n    ]\n\n    # Optional SQLAlchemy Table() instance kwargs\n    schema_kwargs = {\n        #'sqlite_autoincrement': True,\n    }\n</code></pre></p> <p>Tip</p> <p>In general, tables should be plural (posts) while their corresponding ORM model (if you decide to use the ORM) would be singular (post).  This is a convention rather than a rule.</p> <p>If you are using the Uvicore ORM (optional as the database stands alone as a query builder only), and you are defining your table in a separate file, simply point the <code>__tableclass__</code> to the proper table class.</p> <pre><code># ...\nfrom yourname.yourapp.database.tables import posts as table\n\n@uvicore.model()\nclass Post(Model['Post'], metaclass=ModelMetaclass):\n    \"\"\"Yourapp Posts\"\"\"\n\n    # Database table definition\n    # Optional as some models have no database table\n    __tableclass__ = table.Posts\n\n    #...\n</code></pre>"},{"location":"database/tables/#as-orm-model-inline","title":"As ORM Model Inline","text":"<p>If you are using the Uvicore ORM (optional as the database stands alone as a query builder only), and you want to define your tables inline instead of in a separate file, you may do so like this:</p> <pre><code># ...\nfrom yourname.yourapp.database.tables import posts as table\n\n# Get related table names with proper prefixes\nusers = uvicore.db.tablename('auth.users')\n\n@uvicore.model()\nclass Post(Model['Post'], metaclass=ModelMetaclass):\n    \"\"\"Yourapp Posts\"\"\"\n\n    # Database table definition\n    # Optional as some models have no database table\n    __connection__ = 'yourapp'\n    __tablename__ = 'posts'\n    __table__ = [\n        sa.Column('id', sa.Integer, primary_key=True),\n        sa.Column('unique_slug', sa.String(length=100), unique=True),\n        sa.Column('title', sa.String(length=100)),\n        sa.Column('body', sa.Text()),\n        sa.Column('other', sa.String(length=100), nullable=True),\n        sa.Column('creator_id', sa.Integer, sa.ForeignKey(f\"{users}.id\"), nullable=False),\n        sa.Column('owner_id', sa.Integer, sa.ForeignKey(f\"{users}.id\"), nullable=False),\n    ]\n    #...\n</code></pre> <p>init file</p> <p>Be sure to add your models to the <code>models/__init__.py</code></p> <p>See the ORM documentation for more ORM specific details.</p>"},{"location":"features/","title":"Uvicore - Fullstack Async Python","text":"<p>     Feature Packed!       Uvicore is packed with full stack features.  Batteries included out of the box! </p>"},{"location":"features/#full-stack","title":"Full Stack","text":"\" Just get coding with Uvicore and deliver results! \"  <p>Micro frameworks like Flask, Starlette and FastAPI are awesome!!!  So why should you care about  a Full Stack framework like Uvicore?</p> <p>Have you ever tried to use a micro framework in a small to medium size project?  How does it end for you? My experience shows that you end up building your own larger framework in the end.  Here is what I mean:</p> <ul> <li>You start with FastAPI and build a '/hello-world' endpoint.  Awesome, you're a pro!</li> <li>Then you need to talk to MySQL, PostgreSQL, SQLite for testing, MSSQL etc...</li> <li>So you install and hack up a SQLAlchemy connection...somewhere in your folder structure?  Where?</li> <li>Then you realize that a <code>wkr</code> benchmark shows SQLAlchemy blocking all your connections...suddenly FastAPI isn't so fast!</li> <li>So you install <code>encode/databases</code> to add async to your SQL connections, great!</li> <li>Now you have a dozen SQL tables and models + pydantic models.  What does your folder structure look like?</li> <li>You quickly realize that you need redis caching to optimize user results.</li> <li>After sifting through the dozen redis libraries you finally integrate a good async solution!</li> <li>Now you want to raise events and subscribe to those events, you need an event driven architecture, is there a library for that?</li> <li>You realize that if you make a second app there is common functionality you want repeated, so you make a <code>foundation</code> or a <code>framework</code> shared python library for both <code>app1</code> and <code>app2</code>.</li> <li>You quickly realize <code>app1</code> and <code>app2</code> have slightly different needs and require the <code>framework</code> bend to your apps will, you quickly discover the need for <code>Inversion of Control</code> and complex <code>Dependency Injection</code>.</li> <li>With a complex framework with dozens of modules, how do you build a complex and deep-merged configuration system?</li> <li>... on and on it goes ... until it runs away from you and you are lost in complexity.</li> </ul> <p>In the end, what do you have?  A custom built framework with an unwieldy folder structure, hacked up from a dozen libraries.  A framework that you now have to support forever!  A framework that no one else knows except you.  Something non-standard and most likely, unsupported by future developers.  They'll just re-write it anyway.</p> <p>Starting with a micro framework usually ends up with you building and supporting a full stack framework in the end.  Micro frameworks are one small cog in the greater machine, a means to and end.  The end, is almost always a larger more complex framework!</p> <p>Building frameworks is hard and requires a great deal of forethought.  Framework design is a craft and takes a lot of time to master.</p> <p>The developers of Uvicore have focused their 20 year's of experience on building large and complex frameworks.</p> <p>Let Uvicore be your standardized full stack framework, and stop struggling with building the entire world yourself!</p>"},{"location":"features/#dual-routers","title":"Dual Routers","text":"\" Robust OpenAPI/Swagger Routes and/or Jinja2 Templated Web Routes \"  <p>Uvicore provides a blazing fast asynchronous dual routing engine based on FastAPI for API/Swagger endpoints and Starlette for Jinja2 templated MVC routes!</p>"},{"location":"features/#api-router","title":"API Router","text":"<p>These days, most backend systems simply provide RESTful APIs leaving the Frontend up to SPA frameworks like Angular, React and Vue.js.</p> <p>Uvicore abstracts FastAPI into an elegant <code>./http/routes/api.py</code> routes file <pre><code>@uvicore.routes()\nclass Api(Routes):\n    def register(self, route: ApiRouter):\n        \"\"\"Register API Route Endpoints\"\"\"\n\n        # Define controller base path\n        route.controllers = 'acme.wiki.http.api'\n\n        # Public Routes\n        route.controller('welcome')\n\n        # Include dynamic model CRUD API endpoints (the \"auto API\")!\n        # These routes are automatically protected by model.crud style permissions.\n        route.include(ModelRouter, options=uvicore.config.app.api.auto_api)\n</code></pre></p> <p>With simple and beautiful <code>./http/api/*</code> API controllers <pre><code>@uvicore.controller()\nclass Welcome(Controller):\n    def register(self, route: ApiRouter):\n\n        @route.get('/welcome', tags=['Welcome'])\n        async def welcome():\n            return {'welcome': 'to uvicore API!'}\n</code></pre></p> <p>Which produce instant OpenAPI/Swagger Docs! </p>"},{"location":"features/#web-router","title":"Web Router","text":"<p>Standard server-side postback web routes are still in style!  Uvicore provides Jinja2 templated web routes for traditional style website building.</p> <p>The beauty of traditional web development is a single unified language...python!  Sprinkle in a little Javascript via jQuery, Alpine.js or Vue.js and you have a simple and rapid web application without the complexity of a large SPA like Angular or React.  Choice is yours!</p> <p>Leverage the tried and true server-side postback <code>MVC</code> pattern of web development with your <code>./http/routes/web.py</code> router <pre><code>@uvicore.routes()\nclass Web(Routes):\n    def register(self, route: WebRouter):\n        \"\"\"Register Web Route Endpoints\"\"\"\n\n        # Define controller base path\n        route.controllers = 'acme.wiki.http.controllers'\n\n        # Public Routes\n        route.controller('welcome')\n</code></pre></p> <p>And the familiar web controllers in <code>./http/controllers/*</code> <pre><code>@uvicore.controller()\nclass Welcome(Controller):\n    def register(self, route: WebRouter):\n\n        @route.get('/', name='welcome')\n        async def welcome(request: Request):\n            me = uvicore.app.package(main=True)\n            api_config = uvicore.config.app.api\n            return await response.View('wiki/welcome.j2', {\n                'request': request,\n                'app_name': me.name,\n            })\n</code></pre></p> <p>Along with your server side rendered Jinja2 templates in <code>./http/views/*</code> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;body&gt;\n    &lt;div class=\"title\"&gt;\n        Welcome to {{app_name}}\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p>"},{"location":"features/#modular-packages","title":"Modular Packages","text":"\" There is no Shell \"  <p>If you have ever coded in Django, Laravel, Symfony or other full stack frameworks they often provide the concept of packages or bundles as a way to extend your application.  What they all have in common is that they all require you run a Laravel/Django/Symfony shell or \"server\".  So your package/bundle requires some other shell to be ran/served which hosts your package.</p> <p>Uvicore believes that when you create a package, that package should be standalong, meaning you can serve your package without a shall.  BUT you can also include your package inside another package as a dependent \"library\".  In other words, packages ARE apps, and any app can be a library included inside another running app!</p>  \" Override Everything \"  <p>If your app includes other Uvicore packages (as dependent libraries), your app may with to override package configs, views, routes and any other method/class.</p> <ul> <li>Apps are modules</li> <li>Modules are apps</li> <li>Deep overriding of packages configs, routes, assets, views etc...</li> </ul>"},{"location":"features/#inversion-of-control","title":"Inversion of Control","text":"<p> Content Coming Soon...</p>"},{"location":"features/#custom-orm","title":"Custom ORM","text":"<p> Content Coming Soon...</p>"},{"location":"features/#automatic-model-router","title":"Automatic Model Router","text":"<p> Content Coming Soon...</p>"},{"location":"features/#schematic-generators","title":"Schematic Generators","text":"<p> Content Coming Soon...</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/configuration/#structure","title":"Structure","text":"<p>All Uvicore packages contain their own configuration in the <code>config</code> directory.</p> <p></p> <p>The 2 main configs are <code>app.py</code> and <code>package.py</code> of which all other <code>.py</code> files are referenced.</p> <p>When you are \"running\" or \"serving\" your package as an application, the <code>app.py</code> config is used to define all runtime information.  The <code>package.py</code> is also used for package specific configs.</p> <p>When your package is used inside another package (as a shared library for example), the <code>app.py</code> is not used.</p>"},{"location":"getting-started/configuration/#registering-configs","title":"Registering Configs","text":"<p>All packages register their own configs using a unique <code>key</code>, generally your apps name.  This registration is done inside the packages <code>package/provider.py</code> Provider in the <code>register()</code> method.</p> <p>If a config is already registered with the same <code>key</code> then the Dictionary value will be <code>deep merged</code>.  This allows packages to override other package configs at a granular level.  The last provider defined wins.</p> <pre><code>@uvicore.provider()\nclass Myapp(Provider, Cli):\n\n    def register(self) -&gt; None:\n        # Register configs\n        # If config key already exists items will be deep merged allowing\n        # you to override granular aspects of other package configs\n        self.configs([\n            # Here self.name is your packages name (ie: myapp).\n            {'key': self.name, 'value': self.package_config},\n\n            # Example of how to override another packages config with your own.\n            #{'key': 'uvicore.auth', 'module': 'myapp.config.packages.auth.config'},\n        ])\n</code></pre>"},{"location":"getting-started/configuration/#getting-a-config-instance","title":"Getting a Config Instance","text":"<p>You can get hold of the main config instance in many different ways.</p> <p>By importing the <code>uvicore</code> module as a namespace and accessing the config global variable <pre><code>import uvicore\nuvicore.config('app.name')\n</code></pre></p> <p>By importing the <code>uvicore.config</code> global variable directly <pre><code>from uvicore import config\nconfig('app.name')\n</code></pre></p> <p>By \"making\" from the Ioc container <pre><code>import uvicore\nconfig = uvicore.ioc.make('config')  # Other aliases: Configuration, Config\nconfig('app.name')\n</code></pre></p> <p>By using the proper package.  Some classes have the current package as <code>self.package</code>. Or you can find your package from the <code>uvicore.app.package</code> method. <pre><code>import uvicore\npackage = uvicore.app.package('acme/wiki')\npackage.config('cache')\n</code></pre></p>"},{"location":"getting-started/configuration/#usage","title":"Usage","text":"<p>Info</p> <p><code>config</code> is a class with a <code>__call__</code> method so you can use the class like a method <code>config('app.name')</code>.  This is provided as a convenience. Under the hood the <code>__call__</code> simply calls a <code>dotget()</code> method.  Technically you can also get config values by using this <code>dotget()</code> method like so <code>config.dotget('app')</code>.</p> <p>Config is also a uvicore SuperDict!.  This means you can use method style dot notation to access the entire nested config structure like <code>config.app.cache</code>.  So use it like a method <code>config('app')</code> or as method dot notation <code>config.app</code>!</p>"},{"location":"getting-started/configuration/#getting-values","title":"Getting Values","text":"<p>Notice</p> <p>The config system is a large SuperDict.  One of the main differences of a SuperDict is that keys that do not exist to not return <code>None</code>, they return an empty <code>SuperDict({})</code> which allows method style chaining to work properly.  So never check <code>if config.connections is None</code> as it will never be none.  Instead just check <code>if config.connection</code>.  This also means that <code>hasattr(config, 'somekey')</code> will ALWAYS return True even if the key does not exist because it default to <code>SuperDict({})</code>.</p> <p>Get the entire config Dictionary from all packages, completely deep merged based on provider order override <pre><code>config\n# or\nconfig()\n</code></pre></p> <p>Warning</p> <p>Do not use <code>.get()</code>.  Since the config system is essentially a large uvicore SuperDict using <code>.get()</code> is actually a standard python Dictionary <code>.get()</code>.  So <code>.get('onelevel')</code> does work as it would on any dictionary, but <code>.get('onelevel.twolevel')</code> will not.  This is why the <code>.dotget()</code> method exists.  Or just use method style dot notation because its a class like SuperDict! (ex: <code>config.onelevel.twolevel</code>).</p> <p>Get the main <code>app config</code> which is defined in the main running app <code>config/app.py</code> file.  This main app config is not deep merged as it is the only running app config. <pre><code>config.app\n# or\nconfig('app')\n# or\nconfig.dotget('app')\n# or\nconfig['app']\n</code></pre></p> <p>Get a value from the app config <pre><code>config.app.name\n# or\nconfig('app.name')\n# or\nconfig.dotget('app.name')\n# or\nconfig['app']['name']\n</code></pre></p> <p>Get the entire config for a package named <code>acme.wiki</code> and get a few single values.  This is the main wiki config defined in <code>config/wiki.py</code> for example. This config is meant to be overridden as needed by other packages. <pre><code>config.acme.wiki.database.connections\n# or\nconfig('acme.wiki.database.connections')\n# or\nconfig.dotget('acme.wiki.database.connections')\n# or\nconfig['acme']['wiki']['database']['connections']\n</code></pre></p>"},{"location":"getting-started/configuration/#settings-values","title":"Settings Values","text":"<p>Generally you don't want to set config values on-the-fly, but you can because it's just a SuperDict.</p> <p>Sets the entire database connection dictionary with a new one <pre><code>config.app1.database.connections.app1 = Dict({'foo': 'bar'})\n# or\nconfig.dotset('acme.wiki.database.connections', {'foo': 'bar'})\n</code></pre></p> <p>Merges this database connection dictionary with one that already exists <pre><code>config.acme.wiki.database.connections.merge({'foo': 'bar'})\n# or\nconfig.dotget('acme.wiki.database.connections').merge({'foo': 'bar'})\n</code></pre></p>"},{"location":"getting-started/configuration/#digging-deeper","title":"Digging Deeper","text":"<p>The Uvicore framework as a whole is really composed from a series of smaller Uvicore packages.  Just like a personal package you would create using the <code>uvicore-installer</code>.  The configuration system of uvicore is no exception.  The <code>uvicore.configuration</code> package is made up of a standard <code>Service Provider</code> that is bootstrapped as part of a core non-optional dependency automatically added from <code>uvicore.foundation</code>.  This <code>uvicore.configuration</code> package is bootstrapped first thing, high up in the stack and is therefore available to the framework almost immediately.</p> <p>The <code>Configuration</code> class in <code>uvicore/configuration/configuration.py</code> is bound to the <code>IoC</code> as a <code>singleton</code>.  This singleton is deeply merged and overridden by any package further down the bootstrapping chain.  This is what allows packages to override other packages configurations to eventually provide the perfect and complete config.</p> <p>The object inside the config <code>singleton</code> is actually a Uvicore <code>SuperDict</code> which, among many other features, is basically a python <code>Dict</code> on steroids that allows you to access all items using class like dot.notation.</p> <p>You can view all <code>IoC</code> binding by running: <pre><code>./uvicore ioc bindings\n</code></pre></p> <p>Or view only the actual config singleton class by running: <pre><code>./tests/apps/app1/uvicore ioc get uvicore.configuration.configuration.Configuration\n</code></pre></p>"},{"location":"getting-started/deployment/","title":"Deployment","text":"<p> Content Coming Soon...</p>"},{"location":"getting-started/directory-structure/","title":"Directory Structure","text":"<p>A fresh uvicore project called <code>acme.wiki</code> built with the Uvicore Installer will have the following folder structure.</p> <p></p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#up-and-running-in-seconds","title":"Up and Running in Seconds","text":""},{"location":"getting-started/installation/#download-the-uvicore-installer","title":"Download the uvicore-installer","text":"<pre><code>cd ~\nwget https://uvicore.io/uvicore-installer\nchmod a+x uvicore-installer\nsudo mv uvicore-installer /usr/local/bin\n</code></pre>"},{"location":"getting-started/installation/#create-your-app","title":"Create your App","text":"<p><pre><code>cd ~/Code\nuvicore-installer wiki\n</code></pre> </p>"},{"location":"getting-started/installation/#load-your-virtualenv","title":"Load Your Virtualenv","text":"<p><pre><code>cd ~/Code/wiki\n\n# Create your virtual environment using your choice of env packages.\n# poetry shell\n# pipenv shell\n# python -v venv env\n# etc...\n</code></pre> </p>"},{"location":"getting-started/installation/#install-dependencies","title":"Install Dependencies","text":"<p><pre><code># And install the packages using the same environment choice.\n# poetry install\n# pipenv install\n# pip -r requirements.txt\n# etc...\n</code></pre> </p>"},{"location":"getting-started/installation/#uvicore-cli","title":"Uvicore CLI","text":"<p>Run the <code>./uvicore</code> CLI to see all possible options <pre><code>./uvicore\n</code></pre> </p>"},{"location":"getting-started/installation/#welcome-cli-example","title":"Welcome CLI Example","text":"<p>Run your first <code>welcome</code> Async Click CLI stored in <code>./commands/welcome.py</code></p> <p><pre><code>./uvicore wiki welcome\n</code></pre> </p>"},{"location":"getting-started/installation/#uvicore-http-server","title":"Uvicore HTTP Server","text":"<p>Run the Uvicore HTTP Web/API Server</p> <p><pre><code>./uvicore http serve\n</code></pre> </p>"},{"location":"getting-started/installation/#show-openapi-docs","title":"Show OpenAPI Docs","text":"<p>Visit the following</p> <ul> <li> <p>http://localhost:5000 </p> </li> <li> <p>http://localhost:5000/api/docs </p> </li> <li> <p>http://localhost:5000/api/redoc </p> </li> </ul>"},{"location":"http/","title":"HTTP","text":"<p>Uvicore has a blazing fast HTTP Kernel with a dual routing system.</p> <p>Uvicore's API Router use the amazing and blazing fast FastAPI Kernel.</p> <p>Uvicore's Web Router use the amazing and blazing fast Starlette Kernel.</p> <p>In the end, even FastAPI is actually Starlette under the hood.  So the real \"star\" of the HTTP show here in Uvicore is Tom Christie's Starlette and we LOVE it!  Blazing Fast uWSGI!</p> <p>Uvicore makes working with both Web and API routes seamless and integrates extra functionality like RBAC permission control, automatic model routing and Inversion of Control power!</p>"},{"location":"http/api/exceptions/","title":"Exceptions","text":"<p>In uvicore, Web and API endpoints are separated using two route engine.  Each engine has it's own set of middleware, exceptions and other configurations.  Because of this separation you can define exception handlers for each route engine in your <code>config/app.py</code> under <code>web.exceptions</code> and <code>api.exceptions</code>.</p>"},{"location":"http/api/exceptions/#api-exception-handler","title":"API Exception Handler","text":"<p>The default uvicore API exception handler will show a basic JSON response using the proper HTTP response code</p> <pre><code>{\n  \"status_code\": 400,\n  \"message\": \"Bad Parameter\",\n  \"detail\": \"Invalid order_by parameter, possibly invalid JSON?\",\n  \"exception\": \"Expecting value: line 1 column 2 (char 1)\",\n  \"extra\": {\n    \"whatever\": \"you want here, its your dict\"\n  }\n}\n</code></pre> <p>Debug Mode</p> <p>If the raised exception provided an <code>exception=</code> parameter, the exception is ONLY added to the handler if <code>debug=True</code> is set in your <code>config/app.py</code> config.  These are usually the direct results of the <code>try...except</code> stack trace and will be stripped by uvicore for your safety while in production mode.  Never set <code>debug=True</code> in production!</p> <p>To override the generic API handler, create your own method anywhere in your package, for example <code>exceptions/handlers.py</code>.  Then simply change your <code>config/app.py</code> <code>api.exceptions</code> to point to this new location.  You can see Uvicore's default exception handler by looking at the <code>uvicore.http.exceptions.handlers.api</code> method.  Something like this:</p> <pre><code>from uvicore.http import response\nfrom uvicore.http import Request\nfrom starlette.exceptions import HTTPException\n\nasync def api(request: Request, e: HTTPException) -&gt; response.JSON:\n    \"\"\"Main exception handler for all API endpoints\"\"\"\n\n    # Get error payload (smart based on uvicore or starlette HTTPException)\n    (status_code, detail, message, exception, extra, headers) = _get_payload(e)\n    return response.JSON(\n        {\n            \"status_code\": status_code,\n            \"message\": message,\n            \"detail\": detail,\n            \"exception\": exception,\n            \"extra\": extra,\n        }, status_code=status_code, headers=headers\n    )\n</code></pre>"},{"location":"http/api/exceptions/#web-exception-handler","title":"Web Exception Handler","text":"<p>The default Web exception handler will attempt to locate and render a <code>Jinja2</code> template with the same name as the <code>status_code</code> inside a <code>errors</code> view folder.  For example a <code>404</code> error will try to render the <code>errors/404.j2</code> template.  If the template does not exist [in ANY package] it will then attempt to locate and render the <code>errors/catch_all.j2</code> template.  If that templates does not exist in any package it will return a basic HTML page with the error details.  By creating these templates, you have complete control over each individual error including a custom catch all!</p> <p>To create custom error pages, there is no need to touch <code>config/app.py</code> <code>web.exceptions</code> config option.  Instead simply create a <code>http/views/errors/404.j2</code> and <code>http/views/errors/catch_all.j2</code> file in your package and the default Web exception handler will return your new template.  All packages \"view paths\" are combined and merged.  This means if packageA had a custom <code>errors/404.j2</code> and your running app didn't, it would use packageA.  If you created the <code>errors/404.j2</code>, your package would win since it is always defined last.  Everything in Uvicore can be overridden, configs, assets, templates, connections etc... Last package defined generally wins in all override battles.</p> <p>The <code>Jinja2</code> variables available to you in these custom error template are <pre><code>{{ request }}\n{{ status_code }}\n{{ message }}\n{{ detail }}\n{{ exception }} - will always be blank if debug=False\n{{ extra }} - a user defined custom dictionary\n</code></pre></p>"},{"location":"http/api/file-upload/","title":"File Upload","text":"<p>Add these imports to your API controller <pre><code>import aiofiles\nfrom fastapi import UploadFile\n</code></pre></p> <p>Route type hinting like so</p> <pre><code>def register(self, route: ApiRouter):\n\n    @route.post('/train', tags=['MVP'])\n    async def train(csv_data: UploadFile):\n        \"\"\"Train Topic 1, Revison 1 for MVP\"\"\"\n\n        async with aiofiles.open(f\"/tmp/model.sav\", \"wb\") as out_file:\n            content = await csv_data.read()\n            await out_file.write(content)\n\n        # with open(file, \"wb\") as binary_file:\n        #     # Write bytes to file\n        #     binary_file.write(csv_data)\n\n        return {\"filename\": csv_data.filename}\n</code></pre>"},{"location":"http/api/model-router/","title":"API Model Router","text":""},{"location":"http/api/routing/","title":"API Routing","text":""},{"location":"http/api/routing/#new-notes-to-move-around","title":"New notes to move around","text":"<p>These are accurate</p> <p>The auto model router already has <code>model.crud</code> style permissions attached and will require auth as long as you have some api auth middleware enabled.  If you have auth middleware enabled but you still want autoapi routes to be public, or to use a single permission, override it with the options argument on <code>.include()</code></p> <p>This will wipe out all scopes, meaning all auto endpoints are now PUBLIC <pre><code># Include dynamic model CRUD API endpoints (the \"auto API\")!\n# These routes are automatically protected by model.crud style permissions.\n@route.group()\ndef autoapi():\n    route.include(ModelRouter, options={\n        'scopes': []\n    })\n</code></pre></p> <p>This will set all to just 'authenticated', so the <code>model.crud</code> scopes are wiped out. <pre><code># Include dynamic model CRUD API endpoints (the \"auto API\")!\n# These routes are automatically protected by model.crud style permissions.\n@route.group()\ndef autoapi():\n    route.include(ModelRouter, options={\n        'scopes': ['authenticated']\n    })\n</code></pre></p> <p>This will append this scope to the existing auto <code>model.crud</code> scopes. And endpoints are only allows if user has ALL permissions, ie: both <code>['allowcrud', 'posts.read']</code> (unless your <code>admin</code>, it always wins) <pre><code>@route.group(scopes=['allowcrud'])\ndef autoapi():\n    route.include(ModelRouter)\n</code></pre></p>"},{"location":"http/api/routing/#obsolete-warning","title":"OBSOLETE WARNING","text":"<p>This document is obsolete now that I refactored the entire routing infrastructure.</p> <p>Obsolete below this line</p>"},{"location":"http/api/routing/#routing-basics","title":"Routing Basics","text":"<p>Uvicore separates web and api routes into two files located in the <code>http/routes</code> directory.  These route files are loaded from your packages <code>Service Provider</code>. Dual routers allow for separate middleware and authentication mechanisms for web and api endpoints.  Route middleware and authentication is located in your packages <code>config/app.py</code> file.</p> <p>All routes are defined inside the routes <code>register()</code> method. There are multiple ways to define route endpoints including method passing, decorators, groups and controllers.</p> <p>Basic Routing Example <pre><code>import uvicore\nfrom uvicore.http import response\nfrom uvicore.http.routing import Routes, WebRouter\n\n@uvicore.routes()\nclass Web(Routes):\n\n    def register(self, route: WebRouter):\n        \"\"\"Register Web Route Endpoints\"\"\"\n\n        # Define controller base path\n        route.controllers = 'app.http.controllers'\n\n        # Decorators\n        @route.get('/users')\n        def users():\n            return response.Text('Route /usres here')\n\n        # Passing in existing methods\n        def posts():\n            return response.Text('Route /posts here')\n        route.get('/posts', posts)\n\n        # Including controllers\n        from app1.http.controllers.home import Home\n        route.controller(Home)\n\n        # Including controllers as strings using route.controllers path above\n        route.controller('about')  # Assumes app1.http.controllers.home.Home class\n\n        # If your controller has an __init__ with params\n        route.controller('contact', options={'param': 'one'})\n\n        # Groups as a Decorator\n        @route.group(prefix='/admin')\n        def admin():\n            @route.get('/profile')\n            def profile():\n                return response.Text('Route /admin/profile here')\n\n        # Groups as a List of existing methods\n        # tokens and themes methods not defined for brevity\n        route.group(prefix='/settings', routes=[\n            route.get('/tokens', token_settings),\n            route.get('/theme', theme_settings),\n        ])\n</code></pre></p>"},{"location":"http/api/routing/#route-prefixes-and-names","title":"Route Prefixes and Names","text":"<p>All routes are automatically given a route prefix which you define in <code>config/package.py</code>.  This prefix allows consuming developes of your package to alter each packages base URI to fit their needs.  For example, if you wrote a <code>wiki</code> app you probably want a simple <code>/</code> prefix for all routes.  If a developer consumes your wiki as a package inside their own app, they may override your wiki <code>config/package.py</code> and alter the prefix to <code>/wiki</code>.</p> <p>Because of this route prefix, URL paths should never be referenced in views and controllers as they are subject to change and your links will break.  Instead you should always reference the <code>route name</code>.</p> <p>All routes are automatically given a <code>route name</code>.  The name is based on your route path (naturally excluding your package wide prefix).  This name is also prefixed with your package name found in <code>config/package.py</code>.  For example <code>wiki.about</code>, <code>wiki.admin.profile</code>.</p> <p>You can override the automatic name When defining routes, groups and controllers.  Prefixes can be defined on route groups and controllers.</p> <pre><code># Example app where config/package.py name='wiki'\n\n# Default name based on the path\n@route.get('/user/account')\ndef users():\n    return response.Text('Name is wiki.user.account')\n\n# Specifying a custom name\n@route.get('/user/account', name='account')\ndef users():\n    return response.Text('Name is wiki.account')\n\n# Group default name based on path\n@route.group(prefix='/admin')\ndef admin():\n    @route.get('/profile')\n    def profile():\n        return response.Text('Name is wiki.admin.profile')\n\n# Group with a custom name\n@route.group(prefix='/admin', name='backend')\ndef admin():\n    @route.get('/profile')\n    def profile():\n        return response.Text('Name is wiki.backend.profile')\n\n# Controllers are by default not given a name prefix\n# Assuming controller has a /home endpoint\n@route.controller('home')  # name will be wiki.home\n\n# Controllers with a prefix are given a name based on the prefix\n# Assuming controller has a /home endpoint\n@route.controller('home', prefix='my')  # name will be wiki.my.home\n\n# Controllers with a custom name\n# Assuming controller has a /home endpoint\n@route.controller('home', name='our')  # name will be wiki.our.home\n</code></pre>"},{"location":"http/api/routing/#overriding-packages-routes","title":"Overriding Packages Routes","text":"<p>If you are consuming another developers package you may want to override some of their routes with your own.  For example, if you are building a CRM which includes another developers <code>blog</code> packages.  The <code>blog</code> packages has their own <code>/search</code> route which has a name of <code>blog.search</code>.  You want to write a custom CRM search page that overrides the blog search page.</p> <p>Because all of your route names are automatically <code>prefixed</code> with your package name and because all route prefixes are automatically added with your package prefix, you must disable the auto-prefixer for the search route.  This will allow you to define the entire route path and name.</p> <pre><code># Your CRM package wants to override the blog packages search route\n@route.get('/search', name='blog.search', autoprefix=False)\n</code></pre>"},{"location":"http/web/controllers/","title":"Controllers","text":"<p>asdf</p>"},{"location":"http/web/exceptions/","title":"Exceptions","text":""},{"location":"http/web/routing/","title":"Web Routing","text":"<p>asdf</p>"},{"location":"http/web/views/","title":"Views","text":"<p>asdf</p>"},{"location":"http/web/views/#templates-without-http","title":"Templates without HTTP","text":"<p>The template system works with HTTP as a templated response but also without any Web request/response at all.  For example a CLI app that generates HTML-&gt;PDF using the template system.</p> <p>You will notice with the HTTP mixin you get a <code>self.register_http_views</code> and with the Templating mixin you get a <code>self.register_templating_paths</code>.  These both add paths to the same template engine.  The <code>self.register_http_views</code> however only applies with running in HTTP mode (serving the app).  So only <code>self.register_templating_paths</code> are added in CLI+HTTP mode.</p> <p>In your provider include the <code>from uvicore.templating.package.registers import Templating</code> mixin</p> <pre><code># Define template paths\nself.register_templating_paths(['bi.assets.templates'])\n\ndef up_filter(input):\n    return input.upper()\n\ndef up_filter2(context, input):\n    return input.upper()\n\nself.register_templating_context_processors({\n    'context_filters': {\n        'up': up_filter2,\n    },\n    'filters': {\n        'up': up_filter,\n    },\n})\n</code></pre> <p>Now from some non-web code</p> <pre><code>from uvicore.templating.engine import Templates\nhtml = Templates.render('report.j2', {\n    'topLeft': 'Top Left &lt;b&gt;HERE&lt;/b&gt;!!!',\n    'topRight': 'Top Right &lt;b&gt;HERE&lt;/b&gt;!!!',\n    'main': 'report &lt;b&gt;HTML&lt;/b&gt; here!'\n})\ndd(html)\n</code></pre>"}]}